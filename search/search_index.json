{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"COMPAS OCC","text":"<p>COMPAS OCC provides an easy-to-use interface to the Python bindings of the 3D modelling kernel of Open CasCade.</p> <p><code>compas_occ.geometry</code> defines <code>compas_occ.geometry.Curve</code>, <code>compas_occ.geometry.NurbsCurve</code>, <code>compas_occ.geometry.Surface</code> and <code>compas_occ.geometry.NurbsSurface</code>, which are wrappers around <code>Geom_Curve</code>, <code>Geom_BSplineCurve</code>, <code>Geom_Surface</code> and <code>Geom_BSplineSurface</code> of OCC, repsectively.</p> <p>The <code>compas_occ</code> wrappers provide an API for working with NURBS curves and surfaces similar to the API of RhinoCommon. <code>compas_occ.brep</code> is a package for working with Boundary Representation (Brep) objects with the NURBS curves and surfaces of <code>compas_occ.geometry</code> as underlying geometry.</p>"},{"location":"acknowledgements/","title":"Acknowledgements","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#added","title":"Added","text":""},{"location":"changelog/#changed","title":"Changed","text":""},{"location":"changelog/#removed","title":"Removed","text":""},{"location":"changelog/#150-2025-12-11","title":"[1.5.0] 2025-12-11","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Added <code>compas_occ.brep.OCCBrepFace.to_polygons</code> to include also the inner loops.</li> <li>Added <code>compas_occ.brep.OCCBrepLoop.to_polyline</code> for simplified loop conversion.</li> <li>Added <code>compas_occ.brep.OCCBrepLoop.to_polygon</code> for simplified loop conversion.</li> <li>Added <code>compas_occ.brep.OCCBrepVertex.to_point</code> for consistency.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":""},{"location":"changelog/#removed_1","title":"Removed","text":""},{"location":"changelog/#142-2025-10-30","title":"[1.4.2] 2025-10-30","text":""},{"location":"changelog/#added_2","title":"Added","text":""},{"location":"changelog/#changed_2","title":"Changed","text":""},{"location":"changelog/#removed_2","title":"Removed","text":"<ul> <li>Removed <code>schema</code> parameter from <code>OCCBrep.to_step</code> since it is not properly supported.</li> </ul>"},{"location":"changelog/#141-2025-10-30","title":"[1.4.1] 2025-10-30","text":""},{"location":"changelog/#added_3","title":"Added","text":""},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Fixed potential causes of segmentation fault (<code>OCCBrepVertex.is_same</code>, <code>OCCBrepEdge.is_same</code>, <code>OCCBrepLoop.is_same</code>, <code>OCCBrepFace.is_same</code>).</li> </ul>"},{"location":"changelog/#removed_3","title":"Removed","text":""},{"location":"changelog/#140-2025-10-03","title":"[1.4.0] 2025-10-03","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>Added <code>compas_occ.conversions.circle_to_occ2d</code>.</li> <li>Added <code>compas_occ.conversions.ellipse_to_occ2d</code>.</li> <li>Added <code>compas_occ.conversions.frame_to_occ_ax22d</code>.</li> <li>Added <code>compas_occ.conversions.line_to_occ2d</code>.</li> <li>Added <code>compas_occ.conversions.direction_to_occ2d</code>.</li> <li>Added <code>compas_occ.conversions.ax22d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.ax2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.ax2d_to_compas_vector</code>.</li> <li>Added <code>compas_occ.conversions.cylinder2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.direction2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.hyperbola2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.line2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.parabola2d_to_compas</code>.</li> <li>Added <code>compas_occ.conversions.vector2d_to_compas</code>.</li> <li>Added <code>compas_occ.brep.builder.OCCBrepBuilder</code>.</li> <li>Added implementation of <code>compas_occ.brep.OCCBrepFace.__data__</code>.</li> <li>Added implementation of <code>compas_occ.brep.OCCBrep.__data__</code>.</li> <li>Added implementation of <code>compas_occ.brep.OCCBrep.__from_data__</code>.</li> <li>Added support for conversion to OCC .brep format with <code>OCCBrep.to_brep</code>.</li> <li>Added support for writing author, description, ... meta data to STEP files.</li> <li>Added <code>OCCBrep.offset</code>.</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Fixed bug in propagation of linear and angular deflection between discretisation functions <code>OCCBrep.to_viewmesh</code> and <code>OCCBrep.to_tesselation</code>.</li> </ul>"},{"location":"changelog/#removed_4","title":"Removed","text":"<ul> <li>Removed unnecessay instance/type checks in comparison methods of brep components.</li> </ul>"},{"location":"changelog/#130-2025-03-21","title":"[1.3.0] 2025-03-21","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>Added <code>compas_occ.brep.OCCBrep.make_positive</code> which reverses the winding of a solid if it has negative volume.</li> <li>Added <code>compas_occ.brep.OCCBrep.boolean_difference</code> method in addition to the <code>from_boolean_difference</code> constructor.</li> <li>Added <code>compas_occ.brep.OCCBrep.boolean_intersection</code> method in addition to the <code>from_boolean_intersection</code> constructor.</li> <li>Added <code>compas_occ.brep.OCCBrep.boolean_union</code> method in addition to the <code>from_boolean_union</code> constructor.</li> <li>Added <code>compas_occ.conversions.aabb_to_compas</code> to convert an OCC AABB to a COMPAS box.</li> <li>Added <code>compas_occ.conversions.obb_to_compas</code> to convert an OCC OBB to a COMPAS box.</li> <li>Added <code>compas_occ.brep.OCCBrep.aabb</code>.</li> <li>Added <code>compas_occ.brep.OCCBrep.obb</code>.</li> <li>Added <code>compas_occ.brep.OCCBrep.intersect</code>.</li> <li>Added first implementation for <code>compas_occ.brep.OCCBrep.from_loft</code> (not very well tested).</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Changed <code>compas_occ.brep.OCCBrep.heal</code> to inlude <code>make_positive</code>.</li> <li>Changed <code>compas_occ.brep.OCCBrep.points</code> to return only unique points instead of repeating points for every repeated occurrence of a vertex within the data structure.</li> <li>Changed <code>compas_occ.brep.OCCBrep.from_boolean_difference</code> to also accept a list of <code>A</code> shapes.</li> <li>Changed <code>compas_occ.brep.OCCBrep.from_boolean_intersection</code> to also accept lists of shapes for <code>A</code> and <code>B</code>.</li> <li>Changed <code>compas_occ.brep.OCCBrep.from_boolean_union</code> to also accept lists of shapes for <code>A</code> and <code>B</code>.</li> <li>Changed <code>compas_occ.brep.OCCBrep.from_step</code> to convert shells to solid if possible by default.</li> <li>Changed <code>compas_occ.brep.OCCBrep.from_iges</code> to convert shells to solid if possible by default.</li> <li>Fixed bug in <code>compas_occ.brep.OCCBrep.to_stl</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_circle</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_ellipse</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_hyperbola</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_parabola</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_bezier</code>.</li> <li>Fixed malloc problem during Brep edge conversion to curve geometry in <code>OCCBrepEdge.to_bspline</code>.</li> </ul>"},{"location":"changelog/#removed_5","title":"Removed","text":""},{"location":"changelog/#121-2024-07-11","title":"[1.2.1] 2024-07-11","text":""},{"location":"changelog/#added_6","title":"Added","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Changed <code>brepgprop_VolumeProperties</code> to <code>brepgprop.VolumeProperties</code>.</li> <li>Pined <code>pythonocc-core</code> to <code>&lt; 7.8</code> to avoid qt conflict with Pyside6.</li> </ul>"},{"location":"changelog/#removed_6","title":"Removed","text":""},{"location":"changelog/#120-2024-07-06","title":"[1.2.0] 2024-07-06","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.curves.OCCcurve.from_native</code>.</li> <li>Added <code>compas_occ.geometry.curves.OCCNurbsCurve.from_native</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.nurbssurface_from_extrusion</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.nurbssurface_from_plane</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.OCCSurface.from_native</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.OCCNurbsSurface.from_native</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.OCCNurbsSurface.from_plane</code>.</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.curve_from_native</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.nurbscurve_from_native</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.nurbscurve_from_interpolation</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.nurbscurve_from_parameters</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.nurbscurve_from_points</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.curves.nurbscurve_from_step</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.surface_from_native</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_native</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_interpolation</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_fill</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_parameters</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_plane</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_points</code>.</li> <li>Changed plugin name to match pluggable name for <code>compas_occ.geometry.surfaces.nurbssurface_from_step</code>.</li> </ul>"},{"location":"changelog/#removed_7","title":"Removed","text":"<ul> <li>Removed <code>compas_occ.geometry.curves.new_curve</code>.</li> <li>Removed <code>compas_occ.geometry.curves.new_nurbscurve</code>.</li> <li>Removed <code>compas_occ.geometry.surfaces.new_surface</code>.</li> <li>Removed <code>compas_occ.geometry.surfaces.new_nurbssurface</code>.</li> </ul>"},{"location":"changelog/#111-2024-07-03","title":"[1.1.1] 2024-07-03","text":""},{"location":"changelog/#added_8","title":"Added","text":""},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Changed default precision of <code>compas_occ.brep.Brep.simplify</code>.</li> <li>Fixed bug due to import of <code>typing_extensions</code>.</li> </ul>"},{"location":"changelog/#removed_8","title":"Removed","text":""},{"location":"changelog/#110-2024-05-13","title":"[1.1.0] 2024-05-13","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added <code>compas_occ.brep.Brep.from_plane</code>.</li> <li>Added <code>compas_occ.brep.Brep.simplify</code>.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>Changed constructor plugin <code>compas.geometry.curves.new_curve</code> to use <code>super(Curve, cls)</code> (otherwise it doesn't work).</li> <li>Changed constructor plugin <code>compas.geometry.curves.new_nurbscurve</code> to use <code>super(NurbsCurve, cls)</code> (otherwise it doesn't work).</li> </ul>"},{"location":"changelog/#removed_9","title":"Removed","text":""},{"location":"changelog/#102-2024-03-18","title":"[1.0.2] 2024-03-18","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>Added <code>compas_occ.brep.from_planes</code> as plugin for <code>compas.geometry.brep.from_planes</code>.</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Fixed bug in <code>Brep.from_extrusion</code> by adding <code>cap_ends</code> parameter and by raising an exception when it is used :)</li> <li>Fixed bug in <code>Brep.trim</code> by removing the part of the brep that is in front of the trim plane.</li> </ul>"},{"location":"changelog/#removed_10","title":"Removed","text":""},{"location":"changelog/#101-2024-02-03","title":"[1.0.1] 2024-02-03","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.curves.new_nurbscurve_from_native</code>.</li> <li>Added <code>compas_occ.geometry.surfaces.new_nurbssurface_from_native</code>.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Fixed bug in <code>compas_occ.brep.OCCBrep.to_tesselation</code>.</li> </ul>"},{"location":"changelog/#removed_11","title":"Removed","text":""},{"location":"changelog/#100-2024-02-01","title":"[1.0.0] 2024-02-01","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Added <code>OCCBrep.trim</code> and <code>OCCBrep.trimmed</code>.</li> <li>Added <code>OCCBrep.slice</code>.</li> <li>Added <code>OCCBrep.split</code>.</li> <li>Added <code>OCCBrep.fillet</code> and <code>OCCBrep.filleted</code>.</li> <li>Added <code>OCCCurve.parameter_at_distance</code>.</li> <li>Added <code>compas_occ.conversions.compas_frame_from_location</code>.</li> <li>Added <code>OCCBrep.native_brep</code> as alias for <code>OCCBrep.occ_shape</code>.</li> <li>Added <code>is_equal</code> and <code>is_same</code> for <code>OCCBrepVertex</code>, <code>OCCBrepEdge</code>, <code>OCCBrepLoop</code>, <code>OCCBrepFace</code>.</li> <li>Added correct type info to <code>OCCBrepVertex.occ_vertex</code>.</li> <li>Added correct type info to <code>OCCBrepEdge.occ_edge</code>.</li> <li>Added correct type info to <code>OCCBrepLoop.occ_wire</code>.</li> <li>Added correct type info to <code>OCCBrepFace.occ_face</code>.</li> <li>Added <code>OCCBrepLoop.occ_shape</code>.</li> <li>Added <code>OCCBrep.from_iges</code>.</li> <li>Added <code>OCCBrep.to_stl</code>.</li> <li>Added <code>OCCBrep.to_iges</code>.</li> <li>Added <code>OCCBrepVertex.is_same</code> and <code>OCCBrepVertex.is_equal</code>.</li> <li>Added <code>OCCBrepEdge.is_same</code> and <code>OCCBrepEdge.is_equal</code>.</li> <li>Added <code>OCCBrepLoop.is_same</code> and <code>OCCBrepLoop.is_equal</code>.</li> <li>Added <code>OCCBrepFace.is_same</code> and <code>OCCBrepFace.is_equal</code>.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>Changed <code>OCCBrep</code> to be a pluggin for <code>compas.geometry.Brep</code>.</li> <li>Fixed the error when calling <code>OCCBrep.frame</code>.</li> <li>Fixed <code>AttributeError</code> when calling <code>OCCBrep.loops</code>.</li> <li>Updated <code>compas-actions.build</code> workflow to v3.</li> <li>Updated github workflow to latest version.</li> </ul>"},{"location":"changelog/#removed_12","title":"Removed","text":""},{"location":"changelog/#071-2023-03-21","title":"[0.7.1] 2023-03-21","text":""},{"location":"changelog/#added_13","title":"Added","text":""},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Fixed bug in generation of tessellation mesh.</li> </ul>"},{"location":"changelog/#removed_13","title":"Removed","text":""},{"location":"changelog/#070-2022-11-06","title":"[0.7.0] 2022-11-06","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.OCCSurface.from_plane</code>.</li> <li>Added <code>compas_occ.geometry.OCCSurface.intersections_with_curve</code>.</li> <li>Added <code>compas_occ.brep.BRepFace.to_polygon</code>.</li> <li>Added <code>compas_occ.brep.BRep.edge_faces</code>.</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>Changed default units to MM in <code>compas_occ.brep.BRep</code>.</li> </ul>"},{"location":"changelog/#removed_14","title":"Removed","text":""},{"location":"changelog/#060-2022-10-07","title":"[0.6.0] 2022-10-07","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>Added <code>BRep.from_polygons</code>.</li> <li>Added <code>BRep.from_extrusion</code>.</li> <li>Added <code>BRep.from_sweep</code>.</li> <li>Added <code>BRep.to_viewmesh</code>.</li> <li>Added <code>BRep.overlap</code>.</li> <li>Added <code>BRepFace.from_polygon</code>.</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>Fixed bug in <code>BRep.transform</code>.</li> <li>Changed <code>BRep.vertices</code>, <code>BRep.edges</code>, <code>BRep.loops</code>, <code>BRep.faces</code>, <code>BRep.shells</code>, <code>BRep.solids</code> to only be recreated once unerlying shape is changed.</li> <li>Changed implementation of <code>BRep.to_tessellation</code> to use range loop over individual nodes of triangulation instead of node list accessor.</li> </ul>"},{"location":"changelog/#removed_15","title":"Removed","text":""},{"location":"changelog/#050-2022-07-22","title":"[0.5.0] 2022-07-22","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.OCCRevolutionSurface</code>.</li> <li>Added <code>compas_occ.conversions.compas_axis_to_occ_axis</code>.</li> <li>Added <code>compas_occ.conversions.compas_axis_from_occ_axis</code>.</li> <li>Added <code>compas_occ.geometry.OCCExtrusionSurface</code>.</li> <li>Added <code>compas_occ.geometry.OCCNurbsSurface.from_extrusion</code>.</li> <li>Added <code>compas_occ.geometry.OCCCurve.divide_by_count</code>.</li> <li>Added <code>compas_occ.geometry.OCCCurve.divide</code> as alias for <code>compas_occ.geometry.OCCCurve.divide_by_count</code>.</li> <li>Added <code>compas_occ.geometry.OCCCurve.projected</code>.</li> <li>Added <code>compas_occ.geometry.OCCCurve.embedded</code>.</li> <li>Added <code>compas_occ.brep.BRep.from_faces</code>.</li> <li>Added <code>compas_occ.brep.BRep.from_polygons</code>.</li> <li>Added <code>compas_occ.brep.BRep.check</code>.</li> <li>Added <code>compas_occ.brep.BRep.sew</code>.</li> <li>Added <code>compas_occ.brep.BRep.fix</code>.</li> <li>Added <code>compas_occ.brep.BRep.transform</code>.</li> <li>Added <code>compas_occ.brep.BRep.transformed</code>.</li> <li>Added <code>compas_occ.brep.BRep.from_step</code>.</li> <li>Added <code>compas_occ.brep.BRep.from_shape</code>.</li> <li>Added <code>compas_occ.brep.BRep.make_solid</code>.</li> <li>Added <code>compas_occ.brep.BRep.centroid</code>.</li> <li>Added <code>compas_occ.brep.BRep.volume</code>.</li> <li>Added <code>compas_occ.brep.BRep.shells</code>.</li> <li>Added <code>compas_occ.brep.BRep.solids</code>.</li> <li>Added <code>compas_occ.brep.BRep.is_shell</code>.</li> <li>Added <code>compas_occ.brep.BRep.is_solid</code>.</li> <li>Added <code>compas_occ.brep.BRep.slice</code>.</li> <li>Added <code>compas_occ.brep.BRep.split</code>.</li> <li>Added <code>compas_occ.brep.BRepFace.data</code>.</li> <li>Added <code>compas_occ.brep.BRepLoop.data</code>.</li> <li>Added <code>compas_occ.brep.BRepEdge.data</code>.</li> <li>Added <code>compas_occ.brep.BRepVertex.data</code>.</li> <li>Added <code>compas_occ.brep.BRep.area</code>.</li> <li>Added <code>compas_occ.brep.BRepEdge.length</code>.</li> <li>Added <code>compas_occ.brep.BRep.vertex_neighbors</code>.</li> <li>Added <code>compas_occ.brep.BRep.vertex_edges</code>.</li> <li>Added <code>compas_occ.brep.BRep.vertex_faces</code>.</li> <li>Added <code>compas_occ.brep.BRep.from_sweep</code>.</li> <li>Added nurbs conversion to <code>compas_occ.brep.BRepEdge.data</code>.</li> <li>Added nurbs conversion to <code>compas_occ.brep.BRepFace.data</code>.</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>Fixed unused precision parameter in <code>compas_occ.geometry.OCCCurve.length</code>.</li> <li>Fixed bug in <code>compas_occ.brep.BRep.to_meshes</code>.</li> <li>Changed <code>compas_frame_from_occ_position</code> to <code>compas_frame_from_occ_ax3</code>.</li> <li>Changed <code>compas_occ.brep.BRep.to_tesselation</code> to use <code>BRepMesh_IncrementalMesh</code>.</li> <li>Changed base of <code>compas_occ.brep.BRepVertex</code>, <code>compas_occ.brep.BRepEdge</code>, <code>compas_occ.brep.BRepLoop</code>, <code>compas_occ.brep.BRepFace</code>, <code>compas_occ.brep.BRep</code> to <code>compas.data.Data</code>.</li> <li>Changed conversion functions (<code>compas_occ.conversions</code>) to take optional COMPAS type parameter.</li> <li>Changed <code>compas_occ.brep.BRep.data</code> to use component data.</li> </ul>"},{"location":"changelog/#removed_16","title":"Removed","text":""},{"location":"changelog/#042-2022-03-22","title":"[0.4.2] 2022-03-22","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.OCCNurbsCurve.join</code>.</li> <li>Added <code>compas_occ.geometry.OCCNurbsCurve.joined</code>.</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>Extend <code>compas_occ.geometry.OCCNurbsSurface.from_fill</code> with up to 4 input curves.</li> </ul>"},{"location":"changelog/#removed_17","title":"Removed","text":""},{"location":"changelog/#041-2022-03-22","title":"[0.4.1] 2022-03-22","text":""},{"location":"changelog/#added_18","title":"Added","text":""},{"location":"changelog/#changed_18","title":"Changed","text":""},{"location":"changelog/#removed_18","title":"Removed","text":""},{"location":"changelog/#040-2022-02-07","title":"[0.4.0] 2022-02-07","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>Added <code>compas_occ.geometry.OCCCurve</code>.</li> <li>Added <code>compas_occ.geometry.OCCSurface</code>.</li> <li>Added <code>compas_occ.brep.BRep.__add__</code> to support boolean union through \"+\".</li> <li>Added <code>compas_occ.brep.BRep.__sub__</code> to support boolean difference through \"-\".</li> <li>Added <code>compas_occ.brep.BRep.__and__</code> to support boolean intersection through \"&amp;\".</li> </ul>"},{"location":"changelog/#changed_19","title":"Changed","text":"<ul> <li>Changed base class of <code>compas_occ.geometry.OCCNurbsCurve</code> to <code>compas_occ.geometry.OCCCurve</code>.</li> <li>Changed base class of <code>compas_occ.geometry.OCCNurbsSurface</code> to <code>compas_occ.geometry.OCCSurface</code>.</li> <li>Changed <code>compas_occ.brep.BRepEdge</code> to use <code>compas_occ.geometry.OCCCurve</code>.</li> <li>Fixed bug in <code>compas_occ.brep.BRep.to_meshes</code>.</li> <li>Fixed registration of curve plugin constructors to support multiple inheritance.</li> <li>Fixed registration of surface plugin constructors to support multiple inheritance.</li> <li>Fixed <code>compas_occ.geometry.NurbsCurve.copy</code>.</li> </ul>"},{"location":"changelog/#removed_19","title":"Removed","text":""},{"location":"changelog/#034-2022-01-17","title":"[0.3.4] 2022-01-17","text":""},{"location":"changelog/#added_20","title":"Added","text":""},{"location":"changelog/#changed_20","title":"Changed","text":"<ul> <li>Fixed input parameters and docstring of <code>compas_occ.geometry.NurbsSurface.closest_point</code>.</li> <li>Fixed bug in <code>compas_occ.geometry.NurbsCurve.transform</code>.</li> </ul>"},{"location":"changelog/#removed_20","title":"Removed","text":""},{"location":"changelog/#033-2021-12-16","title":"[0.3.3] 2021-12-16","text":""},{"location":"changelog/#added_21","title":"Added","text":""},{"location":"changelog/#changed_21","title":"Changed","text":""},{"location":"changelog/#removed_21","title":"Removed","text":""},{"location":"changelog/#032-2021-12-14","title":"[0.3.2] 2021-12-14","text":""},{"location":"changelog/#added_22","title":"Added","text":"<ul> <li>Added <code>compas_occ.brep.BRep</code>.</li> <li>Added <code>compas_occ.brep.BRepEdge</code>.</li> <li>Added <code>compas_occ.brep.BRepFace</code>.</li> <li>Added <code>compas_occ.brep.BRepLoop</code>.</li> <li>Added <code>compas_occ.brep.BRepVertex</code>.</li> <li>Added <code>compas_occ.geometry.NurbsCurve.segment</code>.</li> <li>Added <code>compas_occ.geometry.NurbsCurve.segmented</code>.</li> <li>Added <code>compas_occ.geometry.NurbsCurve.closest_point</code>.</li> <li>Added <code>compas_occ.geometry.NurbsCurve.curve_closest_parameters</code>.</li> </ul>"},{"location":"changelog/#changed_22","title":"Changed","text":"<ul> <li>Fixed input parameters of <code>new_nurbscurve_from_interpolation</code>.</li> <li>Fixed input parameters of <code>new_nurbscurve_from_step</code>.</li> <li>Fixed error in attributes of empty curve.</li> <li>Fixed error in parameter list of <code>new_nurbscurve</code> plugin.</li> <li>Fixed exception handling in <code>compas_occ.geometry.NurbsCurve.closest_point</code> if no orthogonal projection possible.</li> </ul>"},{"location":"changelog/#removed_22","title":"Removed","text":""},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#curves","title":"Curves","text":""},{"location":"examples/#surfaces","title":"Surfaces","text":""},{"location":"examples/#breps","title":"Breps","text":"<ul> <li>Brep Explorer</li> <li>Brep Fillet</li> <li>Brep Shape From Booleans</li> <li>Brep From Mesh</li> <li>Find the Overlap Between Two Breps</li> <li>Slice a Brep With a Plane</li> <li>Split a Brep With a Plane</li> <li>Trim a Brep With a Plane</li> <li>Brep with Hole</li> <li>Brep with Holes</li> </ul>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#stable","title":"Stable","text":"<pre><code>conda create -n occ -c conda-forge compas_occ\n</code></pre> <p>Several examples use the COMPAS Viewer for visualisation. To install <code>compas_viewer</code> in the same environment</p> <pre><code>conda activate occ\nconda install compas_viewer\n</code></pre>"},{"location":"installation/#development","title":"Development","text":"<p>To get the latest version, and install developer tools, use a local clone of the repo.</p> <pre><code>git clone https://github.com/compas-dev/compas_occ.git\ncd compas_occ\nconda env create -f environment.yml\n</code></pre>"},{"location":"license/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) ETH Zurich - Block Research Group</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial gives a brief overview of the functionality of <code>compas_occ</code> and recommended best practices.</p>"},{"location":"tutorial/#working-with-curves","title":"Working with Curves","text":""},{"location":"tutorial/#working-with-surfaces","title":"Working with Surfaces","text":""},{"location":"tutorial/#working-with-breps","title":"Working with Breps","text":""},{"location":"tutorial/#visualisation","title":"Visualisation","text":""},{"location":"tutorial/#using-the-plugin-system","title":"Using the plugin system","text":"<p><code>compas_occ</code> provides a NURBS and Brep (Boundary Representation) backend for COMPAS based on OpenCasCade. Although it ca be used as a standalone package, the recommended way to use it is through the plugin system. The following snippets accomplish the same thing, but the first uses <code>compas_occ</code> directly, and the second uses it as a plugin.</p> <pre><code>from compas.geometry import Point\nfrom compas_occ.geometry import OCCNurbsCurve\n\npoints = [\n    Point(0, 0, 0),\n    Point(3, 6, 0),\n    Point(6, -3, 3),\n    Point(10, 0, 0)\n]\n\ncurve = OCCNurbsCurve.from_points(points)\n</code></pre> <pre><code>from compas.geometry import Point\nfrom compas.geometry import NurbsCurve\n\npoints = [\n    Point(0, 0, 0),\n    Point(3, 6, 0),\n    Point(6, -3, 3),\n    Point(10, 0, 0)\n]\n\ncurve = NurbsCurve.from_points(points)\n</code></pre> <p>The advatage of using the plugin system is that it allows COMPAS to automatically switch to different backends depending on the current environment without chaging the script. For example, when working in Rhino, the first script will throw an error, whereas the second script will work as expected by switching to RhinoCommon as a backend.</p>"},{"location":"api/compas_occ.brep.OCCBrep/","title":"OCCBrep","text":""},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep","title":"OCCBrep","text":"<pre><code>OCCBrep()\n</code></pre> <p>Class for Boundary Representation of geometric entities.</p> <p>Attributes:</p> <ul> <li> <code>vertices</code>               (<code>list[OCCBrepVertex]</code>)           \u2013            <p>The vertices of the Brep.</p> </li> <li> <code>edges</code>               (<code>list[OCCBrepEdge]</code>)           \u2013            <p>The edges of the Brep.</p> </li> <li> <code>loops</code>               (<code>list[OCCBrepLoop]</code>)           \u2013            <p>The loops of the Brep.</p> </li> <li> <code>faces</code>               (<code>list[OCCBrepFace]</code>)           \u2013            <p>The faces of the Brep.</p> </li> <li> <code>frame</code>               (<code>Frame</code>)           \u2013            <p>The local coordinate system of the Brep.</p> </li> <li> <code>area</code>               (<code>float</code>)           \u2013            <p>The surface area of the Brep.</p> </li> <li> <code>volume</code>               (<code>float</code>)           \u2013            <p>The volume of the regions contained by the Brep.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep-functions","title":"Functions","text":""},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.__from_data__","title":"__from_data__  <code>classmethod</code>","text":"<pre><code>__from_data__(data: dict) -&gt; OCCBrep\n</code></pre> <p>Construct an OCCBrep from its data representation.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>The data dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.boolean_difference","title":"boolean_difference","text":"<pre><code>boolean_difference(*others: OCCBrep, tol=None) -&gt; OCCBrep\n</code></pre> <p>Return the boolean difference of this shape and a collection of other shapes.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>OCCBrep</code>, default:                   <code>()</code> )           \u2013            <p>A collection of other BRep shapes to subtract from the current shape.</p> </li> </ul> Results <p>OCCBrep     The difference between the current shape and the other shapes.</p> <p>Raises:</p> <ul> <li> <code>BrepBooleanError</code>             \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.boolean_intersection","title":"boolean_intersection","text":"<pre><code>boolean_intersection(*others: OCCBrep, tol=None) -&gt; OCCBrep\n</code></pre> <p>Return the boolean intersection of the current shape and a collection of other shapes.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>OCCBrep</code>, default:                   <code>()</code> )           \u2013            <p>A collection of other BRep shapes to intersect with the current shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            <p>The intersection between the current shape and the others.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BrepBooleanError</code>             \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.boolean_union","title":"boolean_union","text":"<pre><code>boolean_union(*others: OCCBrep, tol=None) -&gt; OCCBrep\n</code></pre> <p>Return the boolean union of the current shape and a collection of other shapes.</p> <p>Parameters:</p> <ul> <li> <code>others</code>               (<code>OCCBrep</code>, default:                   <code>()</code> )           \u2013            <p>A collection of other BRep shapes to unite with the current shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            <p>The union between the current shape and the others.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BrepBooleanError</code>             \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.check","title":"check","text":"<pre><code>check()\n</code></pre> <p>Check the shape.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.contours","title":"contours","text":"<pre><code>contours(planes: list[Plane]) -&gt; list[list[Polyline]]\n</code></pre> <p>Generate contour lines by slicing the BRep shape with a series of planes.</p> <p>Parameters:</p> <ul> <li> <code>planes</code>               (<code>list[Plane]</code>)           \u2013            <p>The slicing planes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[list[Polyline]]</code>           \u2013            <p>A list of polylines per plane.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCBrep\n</code></pre> <p>Deep-copy this BRep using the native OCC copying mechanism.</p> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.cull_unused_edges","title":"cull_unused_edges","text":"<pre><code>cull_unused_edges() -&gt; None\n</code></pre> <p>Remove all unused edges.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.cull_unused_faces","title":"cull_unused_faces","text":"<pre><code>cull_unused_faces() -&gt; None\n</code></pre> <p>Remove all unused faces.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.cull_unused_loops","title":"cull_unused_loops","text":"<pre><code>cull_unused_loops() -&gt; None\n</code></pre> <p>Remove all unused loops.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.cull_unused_vertices","title":"cull_unused_vertices","text":"<pre><code>cull_unused_vertices() -&gt; None\n</code></pre> <p>Remove all unused vertices.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.edge_faces","title":"edge_faces","text":"<pre><code>edge_faces(edge: OCCBrepEdge) -&gt; list[OCCBrepFace]\n</code></pre> <p>Identify the faces connected to an edge.</p> <p>Parameters:</p> <ul> <li> <code>edge</code>               (<code>OCCBrepEdge</code>)           \u2013            <p>An edge of the Brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrepFace]</code>           \u2013            <p>The faces connected to the given edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.edge_loops","title":"edge_loops","text":"<pre><code>edge_loops(edge: OCCBrepEdge) -&gt; list[OCCBrepLoop]\n</code></pre> <p>Identify the parent loops of an edge.</p> <p>Parameters:</p> <ul> <li> <code>edge</code>               (<code>OCCBrepEdge</code>)           \u2013            <p>An edge of the Brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrepLoop]</code>           \u2013            <p>The loops containing the given edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.fillet","title":"fillet","text":"<pre><code>fillet(radius: float, exclude: list[OCCBrepEdge] | None = None) -&gt; None\n</code></pre> <p>Fillet the edges of a BRep.</p> <p>Parameters:</p> <ul> <li> <code>radius</code>               (<code>float</code>)           \u2013            <p>The radius of the fillet.</p> </li> <li> <code>exclude</code>               (<code>list[OCCBrepEdge] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of edges to exclude from the fillet operation.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>BrepFilletError</code>             \u2013            <p>If the fillet operation could not be completed.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            <p>the Brep is modified in-place.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.filleted","title":"filleted","text":"<pre><code>filleted(radius: float, exclude: list[OCCBrepEdge] | None = None) -&gt; OCCBrep\n</code></pre> <p>Construct a copy of a Brep with filleted edges.</p> <p>Parameters:</p> <ul> <li> <code>radius</code>               (<code>float</code>)           \u2013            <p>The radius of the fillet.</p> </li> <li> <code>exclude</code>               (<code>list[OCCBrepEdge] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of edges to exclude from the fillet operation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.fix","title":"fix","text":"<pre><code>fix()\n</code></pre> <p>Fix the shell.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_boolean_difference","title":"from_boolean_difference  <code>classmethod</code>","text":"<pre><code>from_boolean_difference(\n    A: OCCBrep | list[OCCBrep], B: OCCBrep | list[OCCBrep], tol=None\n) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from the boolean difference of two other BReps.</p> <p>Parameters:</p> <ul> <li> <code>A</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps to subtract from.</p> </li> <li> <code>B</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps to subtract.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_boolean_intersection","title":"from_boolean_intersection  <code>classmethod</code>","text":"<pre><code>from_boolean_intersection(\n    A: OCCBrep | list[OCCBrep], B: OCCBrep | list[OCCBrep], tol=None\n) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from the boolean intersection of two other BReps.</p> <p>Parameters:</p> <ul> <li> <code>A</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps.</p> </li> <li> <code>B</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>BrepBooleanError</code>             \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_boolean_union","title":"from_boolean_union  <code>classmethod</code>","text":"<pre><code>from_boolean_union(\n    A: OCCBrep | list[OCCBrep], B: OCCBrep | list[OCCBrep], tol=None\n) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from the boolean union of two other BReps.</p> <p>Parameters:</p> <ul> <li> <code>A</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps.</p> </li> <li> <code>B</code>               (<code>OCCBrep | list[OCCBrep]</code>)           \u2013            <p>A OCCBrep or list of OCCBreps.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>BrepBooleanError</code>             \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_box","title":"from_box  <code>classmethod</code>","text":"<pre><code>from_box(box: Box) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS box.</p> <p>Parameters:</p> <ul> <li> <code>box</code>               (<code>Box</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_brepfaces","title":"from_brepfaces  <code>classmethod</code>","text":"<pre><code>from_brepfaces(faces: list[OCCBrepFace], solid: bool = True) -&gt; OCCBrep\n</code></pre> <p>Make a BRep from a list of BRep faces forming an open or closed shell.</p> <p>Parameters:</p> <ul> <li> <code>faces</code>               (<code>list[OCCBrepFace]</code>)           \u2013            <p>The input faces.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating that if the resulting shape should be converted to a solid, if possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_breps","title":"from_breps  <code>classmethod</code>","text":"<pre><code>from_breps(breps: list[OCCBrep]) -&gt; OCCBrep\n</code></pre> <p>Construct one compound BRep out of multiple individual BReps.</p>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_cone","title":"from_cone  <code>classmethod</code>","text":"<pre><code>from_cone(cone: Cone) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS cone.</p> <p>Parameters:</p> <ul> <li> <code>cone</code>               (<code>Cone</code>)           \u2013            <p>A COMPAS cone.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_curves","title":"from_curves  <code>classmethod</code>","text":"<pre><code>from_curves(curves: list[NurbsCurve]) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a set of curves.</p> <p>Parameters:</p> <ul> <li> <code>curves</code>               (<code>list[NurbsCurve]</code>)           \u2013            <p>The input curves.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            <p>The resulting BRep.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_cylinder","title":"from_cylinder  <code>classmethod</code>","text":"<pre><code>from_cylinder(cylinder: Cylinder) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS cylinder.</p> <p>Parameters:</p> <ul> <li> <code>cylinder</code>               (<code>Cylinder</code>)           \u2013            <p>A COMPAS cylinder.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_extrusion","title":"from_extrusion  <code>classmethod</code>","text":"<pre><code>from_extrusion(\n    profile: OCCBrepEdge | OCCBrepFace, vector: Vector, cap_ends: bool = False\n) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep by extruding a closed curve along a direction vector.</p> <p>Parameters:</p> <ul> <li> <code>profile</code>               (<code>OCCBrepEdge | OCCBrepFace</code>)           \u2013            <p>The base profile of the extrusion.</p> </li> <li> <code>vector</code>               (<code>Vector</code>)           \u2013            <p>The extrusion vector. The extrusion has the same height as the length vector.</p> </li> <li> <code>cap_ends</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating that the ends of the brep should be capped. Currently this flag is not supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_iges","title":"from_iges  <code>classmethod</code>","text":"<pre><code>from_iges(filename: str | Path, solid: bool = True) -&gt; OCCBrep\n</code></pre> <p>Conctruct a BRep from the data contained in a IGES file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>The file.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, convert shells to solids when possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_loft","title":"from_loft  <code>classmethod</code>","text":"<pre><code>from_loft(\n    curves: list[OCCCurve], start: Point | None = None, end: Point | None = None\n) -&gt; OCCBrep\n</code></pre> <p>Construct a Brep by lofing through a sequence of curves.</p> <p>Parameters:</p> <ul> <li> <code>curves</code>               (<code>list[OCCCurve]</code>)           \u2013            <p>The loft curves.</p> </li> <li> <code>start</code>               (<code>Point | None</code>, default:                   <code>None</code> )           \u2013            <p>The start point of the loft.</p> </li> <li> <code>end</code>               (<code>Point | None</code>, default:                   <code>None</code> )           \u2013            <p>The end point of the loft.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_mesh","title":"from_mesh  <code>classmethod</code>","text":"<pre><code>from_mesh(mesh: Mesh, solid: bool = True) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS mesh.</p> <p>Parameters:</p> <ul> <li> <code>mesh</code>               (<code>Mesh</code>)           \u2013            <p>The input mesh.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating that if the resulting shape should be converted to a solid, if possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(shape: TopoDS_Shape) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from an OCC shape.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>TopoDS_Shape</code>)           \u2013            <p>The OCC shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_plane","title":"from_plane  <code>classmethod</code>","text":"<pre><code>from_plane(\n    plane: Plane,\n    domain_u: tuple[float, float] = (-1.0, +1.0),\n    domain_v: tuple[float, float] = (-1.0, +1.0),\n) -&gt; OCCBrep\n</code></pre> <p>Make a BRep from a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>A COMPAS plane.</p> </li> <li> <code>domain_u</code>               (<code>tuple[float, float]</code>, default:                   <code>(-1.0, +1.0)</code> )           \u2013            <p>The domain of the plane in the U direction.</p> </li> <li> <code>domain_v</code>               (<code>tuple[float, float]</code>, default:                   <code>(-1.0, +1.0)</code> )           \u2013            <p>The domain of the plane in the V direction.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_planes","title":"from_planes  <code>classmethod</code>","text":"<pre><code>from_planes(planes: list[Plane], solid: bool = True) -&gt; OCCBrep\n</code></pre> <p>Make a BRep from a list of planes.</p> <p>Parameters:</p> <ul> <li> <code>planes</code>               (<code>list[Plane]</code>)           \u2013            <p>The input planes.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating that if the resulting shape should be converted to a solid, if possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_polygons","title":"from_polygons  <code>classmethod</code>","text":"<pre><code>from_polygons(polygons: list[Polygon], solid: bool = True) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a set of polygons.</p> <p>Parameters:</p> <ul> <li> <code>polygons</code>               (<code>list[Polygon]</code>)           \u2013            <p>The input polygons.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Flag indicating that if the resulting shape should be converted to a solid, if possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_shape","title":"from_shape  <code>classmethod</code>","text":"<pre><code>from_shape(shape: TopoDS_Shape) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from an OCC shape.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>TopoDS_Shape</code>)           \u2013            <p>The OCC shape.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_sphere","title":"from_sphere  <code>classmethod</code>","text":"<pre><code>from_sphere(sphere: Sphere) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS sphere.</p> <p>Parameters:</p> <ul> <li> <code>sphere</code>               (<code>Sphere</code>)           \u2013            <p>A COMPAS sphere.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_step","title":"from_step  <code>classmethod</code>","text":"<pre><code>from_step(filename: str | Path, heal: bool = False, solid: bool = False) -&gt; OCCBrep\n</code></pre> <p>Conctruct a BRep from the data contained in a STEP file.</p> <p>Parameters:</p> <ul> <li> <code>filename</code>               (<code>str | Path</code>)           \u2013            <p>The file.</p> </li> <li> <code>solid</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, convert shells to solids when possible.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_surface","title":"from_surface  <code>classmethod</code>","text":"<pre><code>from_surface(\n    surface: Surface | OCCNurbsSurface,\n    domain_u: tuple[float, float] | None = None,\n    domain_v: tuple[float, float] | None = None,\n    precision: float = 1e-06,\n    loop: OCCBrepLoop | None = None,\n    inside: bool = True,\n) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS surface.</p> <p>Parameters:</p> <ul> <li> <code>surface</code>               (<code>Surface | OCCNurbsSurface</code>)           \u2013            <p>The input surface.</p> </li> <li> <code>domain_u</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The domain of the surface in the U direction.</p> </li> <li> <code>domain_v</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The domain of the surface in the V direction.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The precision of the discretisation of the surface.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>The loop to trim the surface with.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to keep the inside or outside of the loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_sweep","title":"from_sweep  <code>classmethod</code>","text":"<pre><code>from_sweep(profile: OCCBrepEdge | OCCBrepFace, path: OCCBrepLoop) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep by sweeping a profile along a path.</p> References <p>https://dev.opencascade.org/doc/occt-7.4.0/refman/html/class_b_rep_prim_a_p_imakesweep.html https://dev.opencascade.org/doc/occt-7.4.0/refman/html/class_b_rep_offset_a_p_i_make_pipe.html https://dev.opencascade.org/doc/occt-7.4.0/refman/html/class_b_rep_offset_a_p_i___make_pipe_shell.html</p>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.from_torus","title":"from_torus  <code>classmethod</code>","text":"<pre><code>from_torus(torus: Torus) -&gt; OCCBrep\n</code></pre> <p>Construct a BRep from a COMPAS torus.</p> <p>Parameters:</p> <ul> <li> <code>torus</code>               (<code>Torus</code>)           \u2013            <p>A COMPAS torus.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.heal","title":"heal","text":"<pre><code>heal()\n</code></pre> <p>Heal the shape.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.intersect","title":"intersect","text":"<pre><code>intersect(other: OCCBrep) -&gt; OCCBrep | None\n</code></pre> <p>Intersect this Brep with another.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrep</code>)           \u2013            <p>The other brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            <p>If it exists, the intersection is a curve that can be accessed via the edges of the returned brep.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.make_positive","title":"make_positive","text":"<pre><code>make_positive()\n</code></pre> <p>Make the volume of a closed brep positive if it is not.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.make_solid","title":"make_solid","text":"<pre><code>make_solid()\n</code></pre> <p>Convert the current shape to a solid if it is a shell.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.offset","title":"offset","text":"<pre><code>offset(distance: float) -&gt; OCCBrep\n</code></pre> <p>Construct a thickened copy of the brep.</p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>float</code>)           \u2013            <p>The thickness in the form of an offset distance.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.overlap","title":"overlap","text":"<pre><code>overlap(\n    other: OCCBrep,\n    linear_deflection: float | None = None,\n    angular_deflection: float | None = None,\n    tolerance: float = 0.0,\n    relative: bool = False,\n) -&gt; tuple[list[OCCBrepFace], list[OCCBrepFace]]\n</code></pre> <p>Compute the overlap between this BRep and another.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrep</code>)           \u2013            <p>The other brep.</p> </li> <li> <code>linear_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum linear deflection for shape approximation.</p> </li> <li> <code>angular_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Maximum angular deflection for shape approximation.</p> </li> <li> <code>tolerance</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Allowable deviation between shapes.</p> </li> </ul> <p>Other Parameters:</p> <ul> <li> <code>relative</code>               (<code>bool</code>)           \u2013            <p>If True, linear deflection used for faces is the maximum linear deflection of their edges.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[OCCBrepFace], list[OCCBrepFace]]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.sew","title":"sew","text":"<pre><code>sew()\n</code></pre> <p>Sew together the individual parts of the shape.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.simplify","title":"simplify","text":"<pre><code>simplify(\n    merge_edges: bool = True,\n    merge_faces: bool = True,\n    lineardeflection: float | None = None,\n    angulardeflection: float | None = None,\n)\n</code></pre> <p>Simplify the shape by merging colinear edges and coplanar faces.</p> <p>Parameters:</p> <ul> <li> <code>merge_edges</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Merge edges with the same underlying geometry.</p> </li> <li> <code>merge_faces</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Merge faces with the same underlying geometry.</p> </li> <li> <code>lineardeflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Default is <code>compas.tolerance.Tolerance.lineardeflection</code>.</p> </li> <li> <code>angulardeflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Default is <code>compas.tolerance.Tolerance.angulardeflection</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.slice","title":"slice","text":"<pre><code>slice(plane: Plane) -&gt; OCCBrep | None\n</code></pre> <p>Slice a BRep with a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>The slicing plane.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep | None</code>           \u2013            <p>The resulting Brep slice or None if the plane does not intersect the Brep.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.split","title":"split","text":"<pre><code>split(other: OCCBrep) -&gt; list[OCCBrep]\n</code></pre> <p>Split a BRep using another BRep as splitter.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrep</code>)           \u2013            <p>Another brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrep]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_brep","title":"to_brep","text":"<pre><code>to_brep(filepath: str | Path) -&gt; None\n</code></pre> <p>Write the BRep shape to a BREP file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path</code>)           \u2013            <p>Location of the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_iges","title":"to_iges","text":"<pre><code>to_iges(filepath: str | Path) -&gt; bool\n</code></pre> <p>Write the BRep shape to a IGES file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path</code>)           \u2013            <p>Location of the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_meshes","title":"to_meshes","text":"<pre><code>to_meshes(u: int = 16, v: int = 16) -&gt; list[Mesh]\n</code></pre> <p>Convert the faces of the BRep shape to meshes.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The number of mesh faces in the U direction of the underlying surface geometry of every face of the Brep.</p> </li> <li> <code>v</code>               (<code>int</code>, default:                   <code>16</code> )           \u2013            <p>The number of mesh faces in the V direction of the underlying surface geometry of every face of the Brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Mesh]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_polygons","title":"to_polygons","text":"<pre><code>to_polygons() -&gt; list[Polygon]\n</code></pre> <p>Convert the faces of the BRep to simple polygons without underlying geometry.</p> <p>Returns:</p> <ul> <li> <code>list[Polygon]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_step","title":"to_step","text":"<pre><code>to_step(\n    filepath: str | Path,\n    unit: str = \"MM\",\n    author: str | None = None,\n    name: str | None = None,\n    description: str | None = None,\n    organization: str | None = None,\n) -&gt; None\n</code></pre> <p>Write the BRep shape to a STEP file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path</code>)           \u2013            <p>Location of the file.</p> </li> <li> <code>unit</code>               (<code>str</code>, default:                   <code>'MM'</code> )           \u2013            <p>Base units for the geometry in the file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_stl","title":"to_stl","text":"<pre><code>to_stl(\n    filepath: str | Path,\n    linear_deflection: float = 0.001,\n    angular_deflection: float = 0.5,\n) -&gt; bool\n</code></pre> <p>Write the BRep shape to a STL file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str | Path</code>)           \u2013            <p>Location of the file.</p> </li> <li> <code>linear_deflection</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>Allowable deviation between curved geometry and mesh discretisation.</p> </li> <li> <code>angular_deflection</code>               (<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Maximum angle between two adjacent facets.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_tesselation","title":"to_tesselation","text":"<pre><code>to_tesselation(\n    linear_deflection: float | None = None, angular_deflection: float | None = None\n) -&gt; tuple[Mesh, list[Polyline]]\n</code></pre> <p>Create a tesselation of the shape for visualisation.</p> <p>Parameters:</p> <ul> <li> <code>linear_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Allowable \"distance\" deviation between curved geometry and mesh discretisation.</p> </li> <li> <code>angular_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Allowable \"curvature\" deviation between curved geometry and mesh discretisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Mesh, list[Polyline]]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.to_viewmesh","title":"to_viewmesh","text":"<pre><code>to_viewmesh(\n    linear_deflection: float | None = None, angular_deflection: float | None = None\n) -&gt; tuple[Mesh, list[Polyline]]\n</code></pre> <p>Convert the BRep to a view mesh.</p> <p>Parameters:</p> <ul> <li> <code>linear_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Allowable \"distance\" deviation between curved geometry and mesh discretisation.</p> </li> <li> <code>angular_deflection</code>               (<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Allowable \"curvature\" deviation between curved geometry and mesh discretisation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Mesh, list[Polyline]]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.transform","title":"transform","text":"<pre><code>transform(matrix: Transformation) -&gt; None\n</code></pre> <p>Transform this Brep.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>Transformation</code>)           \u2013            <p>A transformation matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.transformed","title":"transformed","text":"<pre><code>transformed(matrix: Transformation) -&gt; OCCBrep\n</code></pre> <p>Return a transformed copy of the Brep.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>Transformation</code>)           \u2013            <p>A transformation matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.trim","title":"trim","text":"<pre><code>trim(plane: Plane) -&gt; None\n</code></pre> <p>Trim a Brep with a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>The slicing plane.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.trimmed","title":"trimmed","text":"<pre><code>trimmed(plane: Plane) -&gt; OCCBrep\n</code></pre> <p>Construct a copy of a Brep trimmed with a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>The slicing plane.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrep</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.vertex_edges","title":"vertex_edges","text":"<pre><code>vertex_edges(vertex: OCCBrepVertex) -&gt; list[OCCBrepEdge]\n</code></pre> <p>Identify the edges connected to a given vertex.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>A vertex of the Brep</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrepEdge]</code>           \u2013            <p>The edges connected to the given vertex.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.vertex_faces","title":"vertex_faces","text":"<pre><code>vertex_faces(vertex: OCCBrepVertex) -&gt; list[OCCBrepFace]\n</code></pre> <p>Identify the faces connected to a vertex.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>A vertex of the Brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrepFace]</code>           \u2013            <p>The faces connected to the given vertex.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrep/#compas_occ.brep.OCCBrep.vertex_neighbors","title":"vertex_neighbors","text":"<pre><code>vertex_neighbors(vertex: OCCBrepVertex) -&gt; list[OCCBrepVertex]\n</code></pre> <p>Identify the neighbouring vertices of a given vertex.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>A vertex of the Brep.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[OCCBrepVertex]</code>           \u2013            <p>The neighbouring vertices of the given vertex.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/","title":"OCCBrepEdge","text":""},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge","title":"OCCBrepEdge","text":"<pre><code>OCCBrepEdge(occ_edge: TopoDS_Edge)\n</code></pre> <p>Class representing an edge in the BRep of a geometric shape.</p> <p>Parameters:</p> <ul> <li> <code>occ_edge</code>               (<code>TopoDS_Edge</code>)           \u2013            <p>An OCC BRep edge.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>curve</code>               (<code>Curve</code>)           \u2013            <p>Curve geometry from the edge adaptor.</p> </li> <li> <code>first_vertex</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The first vertex with forward orientation.</p> </li> <li> <code>is_line</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a line.</p> </li> <li> <code>is_circle</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a circle.</p> </li> <li> <code>is_ellipse</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is an ellipse.</p> </li> <li> <code>is_hyperbola</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a hyperbola.</p> </li> <li> <code>is_parabola</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a parabola.</p> </li> <li> <code>is_bezier</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a bezier curve.</p> </li> <li> <code>is_bspline</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is a bspline curve.</p> </li> <li> <code>is_other</code>               (<code>bool</code>)           \u2013            <p>True if the underlying curve is an other type of curve.</p> </li> <li> <code>last_vertex</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The first vertex with reversed orientation.</p> </li> <li> <code>vertices</code>               (<code>list[OCCBrepVertex]</code>)           \u2013            <p>The topological vertices of the edge.</p> </li> <li> <code>type</code>               (<code>int</code>)           \u2013            <p>The type of the geometric curve underlying the topological edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge-functions","title":"Functions","text":""},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_circle","title":"from_circle  <code>classmethod</code>","text":"<pre><code>from_circle(\n    circle: Circle,\n    params: tuple[float, float] | None = None,\n    points: tuple[Point, Point] | None = None,\n    vertices: tuple[OCCBrepVertex, OCCBrepVertex] | None = None,\n) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from a circle.</p> <p>Parameters:</p> <ul> <li> <code>circle</code>               (<code>Circle</code>)           \u2013            <p>The circle.</p> </li> <li> <code>params</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The parameters of the circle.</p> </li> <li> <code>points</code>               (<code>tuple[Point, Point] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end points of the circle.</p> </li> <li> <code>vertices</code>               (<code>tuple[OCCBrepVertex, OCCBrepVertex] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end vertices of the circle.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_curve","title":"from_curve  <code>classmethod</code>","text":"<pre><code>from_curve(\n    curve: OCCCurve,\n    params: tuple[float, float] | None = None,\n    points: tuple[Point, Point] | None = None,\n    vertices: tuple[OCCBrepVertex, OCCBrepVertex] | None = None,\n) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from a curve.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCCurve</code>)           \u2013            <p>The curve.</p> </li> <li> <code>params</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The parameters of the curve.</p> </li> <li> <code>points</code>               (<code>tuple[Point, Point] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end points of the curve.</p> </li> <li> <code>vertices</code>               (<code>tuple[OCCBrepVertex, OCCBrepVertex] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end vertices of the curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_curve2d_and_surface","title":"from_curve2d_and_surface  <code>classmethod</code>","text":"<pre><code>from_curve2d_and_surface(\n    curve2d: OCCCurve2d,\n    surface: OCCSurface,\n    params: tuple[float, float] | None = None,\n    points: tuple[Point, Point] | None = None,\n    vertices: tuple[OCCBrepVertex, OCCBrepVertex] | None = None,\n) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from an embedded 2d curve and its embedding surface.</p> <p>Parameters:</p> <ul> <li> <code>curve2d</code>               (<code>OCCCurve2d</code>)           \u2013            <p>The 2D curve.</p> </li> <li> <code>surface</code>               (<code>OCCSurface</code>)           \u2013            <p>The surface.</p> </li> <li> <code>params</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The parameters of the curve.</p> </li> <li> <code>points</code>               (<code>tuple[Point, Point] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end points of the curve.</p> </li> <li> <code>vertices</code>               (<code>tuple[OCCBrepVertex, OCCBrepVertex] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end vertices of the curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_curve_and_surface","title":"from_curve_and_surface  <code>classmethod</code>","text":"<pre><code>from_curve_and_surface(\n    curve: OCCCurve,\n    surface: OCCSurface,\n    params: tuple[float, float] | None = None,\n    points: tuple[Point, Point] | None = None,\n    vertices: tuple[OCCBrepVertex, OCCBrepVertex] | None = None,\n) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from a curve and a surface.</p> <p>The curve will be projected onto the surface and embedded into its parameter space automatically.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCCurve</code>)           \u2013            <p>The curve.</p> </li> <li> <code>surface</code>               (<code>OCCSurface</code>)           \u2013            <p>The surface.</p> </li> <li> <code>params</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The parameters of the curve.</p> </li> <li> <code>points</code>               (<code>tuple[Point, Point] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end points of the curve.</p> </li> <li> <code>vertices</code>               (<code>tuple[OCCBrepVertex, OCCBrepVertex] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end vertices of the curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_ellipse","title":"from_ellipse  <code>classmethod</code>","text":"<pre><code>from_ellipse(ellipse: Ellipse) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from an ellipse.</p> <p>Parameters:</p> <ul> <li> <code>ellipse</code>               (<code>Ellipse</code>)           \u2013            <p>The ellipse.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_line","title":"from_line  <code>classmethod</code>","text":"<pre><code>from_line(\n    line: Line,\n    params: tuple[float, float] | None = None,\n    points: tuple[Point, Point] | None = None,\n    vertices: tuple[OCCBrepVertex, OCCBrepVertex] | None = None,\n) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from a line.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>Line</code>)           \u2013            <p>The line.</p> </li> <li> <code>params</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>The parameters of the line.</p> </li> <li> <code>points</code>               (<code>tuple[Point, Point] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end points of the line.</p> </li> <li> <code>vertices</code>               (<code>tuple[OCCBrepVertex, OCCBrepVertex] | None</code>, default:                   <code>None</code> )           \u2013            <p>The start and end vertices of the line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_point_point","title":"from_point_point  <code>classmethod</code>","text":"<pre><code>from_point_point(a: Point, b: Point) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from two points.</p> <p>Parameters:</p> <ul> <li> <code>a</code>               (<code>Point</code>)           \u2013            <p>The first point.</p> </li> <li> <code>b</code>               (<code>Point</code>)           \u2013            <p>The second point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.from_vertex_vertex","title":"from_vertex_vertex  <code>classmethod</code>","text":"<pre><code>from_vertex_vertex(a: OCCBrepVertex, b: OCCBrepVertex) -&gt; OCCBrepEdge\n</code></pre> <p>Construct an edge from two vertices.</p> <p>Parameters:</p> <ul> <li> <code>a</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The first vertex.</p> </li> <li> <code>b</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The second vertex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepEdge</code>           \u2013            <p>The constructed edge.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: OCCBrepEdge) -&gt; bool\n</code></pre> <p>Check if this edge is equal to another edge.</p> <p>Two edges are equal if they have the same location and orientation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepEdge</code>)           \u2013            <p>The other edge.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the edges are equal, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.is_same","title":"is_same","text":"<pre><code>is_same(other: OCCBrepEdge) -&gt; bool\n</code></pre> <p>Check if this edge is the same as another edge.</p> <p>Two edges are the same if they have the same location.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepEdge</code>)           \u2013            <p>The other edge.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the edges are the same, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_bezier","title":"to_bezier","text":"<pre><code>to_bezier() -&gt; Bezier\n</code></pre> <p>Convert the edge geometry to a bezier curve.</p> <p>Returns:</p> <ul> <li> <code>Bezier</code>           \u2013            <p>A COMPAS bezier curve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a bezier curve.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_bspline","title":"to_bspline","text":"<pre><code>to_bspline() -&gt; NurbsCurve\n</code></pre> <p>Convert the edge geometry to a bspline.</p> <p>Returns:</p> <ul> <li> <code>NursbCurve</code>           \u2013            <p>A COMPAS bspline curve.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a bspline.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_circle","title":"to_circle","text":"<pre><code>to_circle() -&gt; Circle\n</code></pre> <p>Convert the edge geometry to a circle.</p> <p>Returns:</p> <ul> <li> <code>Circle</code>           \u2013            <p>A COMPAS circle.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a circle.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_ellipse","title":"to_ellipse","text":"<pre><code>to_ellipse() -&gt; Ellipse\n</code></pre> <p>Convert the edge geometry to an ellipse.</p> <p>Returns:</p> <ul> <li> <code>Ellipse</code>           \u2013            <p>A COMPAS ellipse.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not an ellipse.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_hyperbola","title":"to_hyperbola","text":"<pre><code>to_hyperbola() -&gt; Hyperbola\n</code></pre> <p>Convert the edge geometry to a hyperbola.</p> <p>Returns:</p> <ul> <li> <code>Hyperbola</code>           \u2013            <p>A COMPAS hyperbola.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a hyperbola.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_line","title":"to_line","text":"<pre><code>to_line() -&gt; Line\n</code></pre> <p>Convert the edge geometry to a line.</p> <p>Returns:</p> <ul> <li> <code>Line</code>           \u2013            <p>A COMPAS line.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a line.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepEdge/#compas_occ.brep.OCCBrepEdge.to_parabola","title":"to_parabola","text":"<pre><code>to_parabola() -&gt; Parabola\n</code></pre> <p>Convert the edge geometry to a parabola.</p> <p>Returns:</p> <ul> <li> <code>Parabola</code>           \u2013            <p>A COMPAS parabola.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the underlying geometry is not a parabola.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/","title":"OCCBrepFace","text":""},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace","title":"OCCBrepFace","text":"<pre><code>OCCBrepFace(occ_face: TopoDS_Face)\n</code></pre> <p>Class representing a face in the BRep of a geometric shape.</p> <p>Parameters:</p> <ul> <li> <code>occ_face</code>               (<code>TopoDS_Face</code>)           \u2013            <p>An OCC BRep face.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>vertices</code>               (<code>list[OCCBrepVertex]</code>)           \u2013            <p>List of BRep vertices.</p> </li> <li> <code>edges</code>               (<code>list[OCCBrepEdge]</code>)           \u2013            <p>List of BRep edges.</p> </li> <li> <code>loops</code>               (<code>list[OCCBrepLoop]</code>)           \u2013            <p>List of BRep loops.</p> </li> <li> <code>surface</code>           \u2013            <p>Surface geometry from the adaptor.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace-functions","title":"Functions","text":""},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.__from_data__","title":"__from_data__  <code>classmethod</code>","text":"<pre><code>__from_data__(data: dict) -&gt; OCCBrepFace\n</code></pre> <p>Construct an object of this type from the provided data.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>dict</code>)           \u2013            <p>The data dictionary.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            <p>An instance of this object type if the data contained in the dict has the correct schema.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.add_loop","title":"add_loop","text":"<pre><code>add_loop(loop: OCCBrepLoop, reverse: bool = False) -&gt; None\n</code></pre> <p>Add an inner loop to the face.</p> <p>Parameters:</p> <ul> <li> <code>loop</code>               (<code>OCCBrepLoop</code>)           \u2013            <p>The additional loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.add_loops","title":"add_loops","text":"<pre><code>add_loops(loops: list[OCCBrepLoop], reverse: bool = False) -&gt; None\n</code></pre> <p>Add an inner loop to the face.</p> <p>Parameters:</p> <ul> <li> <code>loops</code>               (<code>list[OCCBrepLoop]</code>)           \u2013            <p>The additional loops.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.fix","title":"fix","text":"<pre><code>fix() -&gt; None\n</code></pre> <p>Try to fix the face.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_cone","title":"from_cone  <code>classmethod</code>","text":"<pre><code>from_cone(\n    cone: Cone, loop: OCCBrepLoop | None = None, inside: bool = True\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a cone.</p> <p>Parameters:</p> <ul> <li> <code>cone</code>               (<code>Cone</code>)           \u2013            <p>The cone.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>optional</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_cylinder","title":"from_cylinder  <code>classmethod</code>","text":"<pre><code>from_cylinder(\n    cylinder: Cylinder, loop: OCCBrepLoop | None = None, inside: bool = True\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a cylinder.</p> <p>Parameters:</p> <ul> <li> <code>cylinder</code>               (<code>Cylinder</code>)           \u2013            <p>The cylinder.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>optional</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_plane","title":"from_plane  <code>classmethod</code>","text":"<pre><code>from_plane(\n    plane: Plane,\n    domain_u: tuple[float, float] | None = None,\n    domain_v: tuple[float, float] | None = None,\n    loop: OCCBrepLoop | None = None,\n    inside: bool = True,\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>The plane.</p> </li> <li> <code>domain_u</code>               (<code>tuple[float, float]</code>, default:                   <code>None</code> )           \u2013            <p>U parameter minimum and maximum.</p> </li> <li> <code>domain_v</code>               (<code>tuple[float, float]</code>, default:                   <code>None</code> )           \u2013            <p>V parameter minimum and maximum.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>optional</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_polygon","title":"from_polygon  <code>classmethod</code>","text":"<pre><code>from_polygon(points: Polygon) -&gt; OCCBrepFace\n</code></pre> <p>Construct a BRep face from a polygon.</p> <p>Parameters:</p> <ul> <li> <code>polygon</code>           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_sphere","title":"from_sphere  <code>classmethod</code>","text":"<pre><code>from_sphere(\n    sphere: Sphere, loop: OCCBrepLoop | None = None, inside: bool = True\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a sphere.</p> <p>Parameters:</p> <ul> <li> <code>sphere</code>               (<code>Sphere</code>)           \u2013            <p>The sphere.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>optional</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_surface","title":"from_surface  <code>classmethod</code>","text":"<pre><code>from_surface(\n    surface: OCCSurface,\n    domain_u: tuple[float, float] | None = None,\n    domain_v: tuple[float, float] | None = None,\n    precision: float = 1e-06,\n    loop: OCCBrepLoop | None = None,\n    inside: bool = True,\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a surface.</p> <p>Parameters:</p> <ul> <li> <code>surface</code>               (<code>OCCSurface</code>)           \u2013            <p>The torus.</p> </li> <li> <code>domain_u</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>U parameter minimum and maximum.</p> </li> <li> <code>domain_v</code>               (<code>tuple[float, float] | None</code>, default:                   <code>None</code> )           \u2013            <p>V parameter minimum and maximum.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>Precision for face construction.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.from_torus","title":"from_torus  <code>classmethod</code>","text":"<pre><code>from_torus(\n    torus: Torus, loop: OCCBrepLoop | None = None, inside: bool = True\n) -&gt; OCCBrepFace\n</code></pre> <p>Construct a face from a torus.</p> <p>Parameters:</p> <ul> <li> <code>torus</code>               (<code>Torus</code>)           \u2013            <p>The torus.</p> </li> <li> <code>loop</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>optional</code>               (<code>OCCBrepLoop | None</code>, default:                   <code>None</code> )           \u2013            <p>A boundary loop.</p> </li> <li> <code>inside</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the face is inside the boundary loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepFace</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: OCCBrepFace) -&gt; bool\n</code></pre> <p>Check if this face is equal to another face.</p> <p>Two faces are equal if they have the same location and orientation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepFace</code>)           \u2013            <p>The other face.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the faces are equal, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.is_same","title":"is_same","text":"<pre><code>is_same(other: OCCBrepFace) -&gt; bool\n</code></pre> <p>Check if this face is the same as another face.</p> <p>Two faces are the same if they have the same location.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepFace</code>)           \u2013            <p>The other face.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the faces are the same, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.is_valid","title":"is_valid","text":"<pre><code>is_valid() -&gt; bool\n</code></pre> <p>Verify that the face is valid.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_cone","title":"to_cone","text":"<pre><code>to_cone() -&gt; Cone\n</code></pre> <p>Convert the face surface geometry to a cone.</p> <p>Returns:</p> <ul> <li> <code>Cone</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_cylinder","title":"to_cylinder","text":"<pre><code>to_cylinder() -&gt; Cylinder\n</code></pre> <p>Convert the face surface geometry to a cylinder.</p> <p>Returns:</p> <ul> <li> <code>Cylinder</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_nurbs","title":"to_nurbs","text":"<pre><code>to_nurbs() -&gt; NurbsSurface\n</code></pre> <p>Convert the face surface geometry to a torus.</p> <p>Returns:</p> <ul> <li> <code>NurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_plane","title":"to_plane","text":"<pre><code>to_plane() -&gt; Plane\n</code></pre> <p>Convert the face surface geometry to a plane.</p> <p>Returns:</p> <ul> <li> <code>Plane</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_polygon","title":"to_polygon","text":"<pre><code>to_polygon() -&gt; Polygon\n</code></pre> <p>Convert the face to a polygon without underlying geometry.</p> <p>Returns:</p> <ul> <li> <code>Polygon</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_polygons","title":"to_polygons","text":"<pre><code>to_polygons() -&gt; list[Polygon]\n</code></pre> <p>Convert the face to polygons without underlying geometry.</p> <p>Returns:</p> <ul> <li> <code>list[Polygon]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_sphere","title":"to_sphere","text":"<pre><code>to_sphere() -&gt; Sphere\n</code></pre> <p>Convert the face surface geometry to a sphere.</p> <p>Returns:</p> <ul> <li> <code>Sphere</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.to_torus","title":"to_torus","text":"<pre><code>to_torus() -&gt; Torus\n</code></pre> <p>Convert the face surface geometry to a torus.</p> <p>Returns:</p> <ul> <li> <code>Torus</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepFace/#compas_occ.brep.OCCBrepFace.try_get_nurbssurface","title":"try_get_nurbssurface","text":"<pre><code>try_get_nurbssurface(\n    precision=0.001,\n    continuity_u=None,\n    continuity_v=None,\n    maxdegree_u=5,\n    maxdegree_v=5,\n    maxsegments_u=1,\n    maxsegments_v=1,\n) -&gt; OCCNurbsSurface\n</code></pre> <p>Try to convert the underlying geometry to a Nurbs surface.</p>"},{"location":"api/compas_occ.brep.OCCBrepLoop/","title":"OCCBrepLoop","text":""},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop","title":"OCCBrepLoop","text":"<pre><code>OCCBrepLoop(occ_wire: TopoDS_Wire)\n</code></pre> <p>Class representing an edge loop in the BRep of a geometric shape.</p> <p>Parameters:</p> <ul> <li> <code>occ_wire</code>               (<code>TopoDS_Wire</code>)           \u2013            <p>An OCC BRep wire.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>vertices</code>               (<code>list[OCCBrepVertex]</code>)           \u2013            <p>List of BRep vertices.</p> </li> <li> <code>edges</code>               (<code>list[OCCBrepEdge]</code>)           \u2013            <p>List of BRep edges.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop-functions","title":"Functions","text":""},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.fix","title":"fix","text":"<pre><code>fix() -&gt; None\n</code></pre> <p>Try to fix the loop.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.from_edges","title":"from_edges  <code>classmethod</code>","text":"<pre><code>from_edges(edges: list[OCCBrepEdge]) -&gt; OCCBrepLoop\n</code></pre> <p>Construct a loop from a collection of edges.</p> <p>Parameters:</p> <ul> <li> <code>edges</code>               (<code>list[OCCBrepEdge]</code>)           \u2013            <p>The edges.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepLoop</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.from_polygon","title":"from_polygon  <code>classmethod</code>","text":"<pre><code>from_polygon(polygon: Polygon) -&gt; OCCBrepLoop\n</code></pre> <p>Construct a loop from a polygon.</p> <p>Parameters:</p> <ul> <li> <code>polygon</code>               (<code>Polygon</code>)           \u2013            <p>The polygon.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepLoop</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.from_polyline","title":"from_polyline  <code>classmethod</code>","text":"<pre><code>from_polyline(polyline: Polyline) -&gt; OCCBrepLoop\n</code></pre> <p>Construct a loop from a polyline.</p> <p>Parameters:</p> <ul> <li> <code>polyline</code>               (<code>Polyline</code>)           \u2013            <p>The polyline.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCBrepLoop</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: OCCBrepLoop) -&gt; bool\n</code></pre> <p>Check if this loop is equal to another loop.</p> <p>Two loops are equal if they have the same location and orientation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepLoop</code>)           \u2013            <p>The other loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the loops are equal, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.is_same","title":"is_same","text":"<pre><code>is_same(other: OCCBrepLoop) -&gt; bool\n</code></pre> <p>Check if this loop is the same as another loop.</p> <p>Two loops are the same if they have the same location.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepLoop</code>)           \u2013            <p>The other loop.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the loops are the same, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.to_polygon","title":"to_polygon","text":"<pre><code>to_polygon() -&gt; Polygon\n</code></pre> <p>Convert the loop to a simple polygon without underlying geometry.</p> <p>Returns:</p> <ul> <li> <code>Polygon</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepLoop/#compas_occ.brep.OCCBrepLoop.to_polyline","title":"to_polyline","text":"<pre><code>to_polyline() -&gt; Polyline\n</code></pre> <p>Convert the loop to a polyline.</p> <p>Returns:</p> <ul> <li> <code>Polyline</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepVertex/","title":"OCCBrepVertex","text":""},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex","title":"OCCBrepVertex","text":"<pre><code>OCCBrepVertex(occ_vertex: TopoDS_Vertex)\n</code></pre> <p>Class representing a vertex in the BRep of a geometric shape.</p> <p>Parameters:</p> <ul> <li> <code>occ_vertex</code>               (<code>TopoDS_Vertex</code>)           \u2013            <p>An OCC topological vertex data structure.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>point</code>               (<code>Point</code>)           \u2013            <p>The geometric point underlying the topological vertex.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex-functions","title":"Functions","text":""},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex.from_point","title":"from_point  <code>classmethod</code>","text":"<pre><code>from_point(point: Point) -&gt; BrepVertex\n</code></pre> <p>Construct a vertex from a point.</p> <p>Parameters:</p> <ul> <li> <code>point</code>               (<code>Point</code>)           \u2013            <p>The point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>BrepVertex</code>           \u2013            <p>The vertex.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex.is_equal","title":"is_equal","text":"<pre><code>is_equal(other: OCCBrepVertex) -&gt; bool\n</code></pre> <p>Check if this vertex is equal to another vertex.</p> <p>Two vertices are equal if they have the same location and orientation.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The other vertex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the vertices are equal, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex.is_same","title":"is_same","text":"<pre><code>is_same(other: OCCBrepVertex) -&gt; bool\n</code></pre> <p>Check if this vertex is the same as another vertex.</p> <p>Two vertices are the same if they have the same location.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>OCCBrepVertex</code>)           \u2013            <p>The other vertex.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p><code>True</code> if the vertices are the same, <code>False</code> otherwise.</p> </li> </ul>"},{"location":"api/compas_occ.brep.OCCBrepVertex/#compas_occ.brep.OCCBrepVertex.to_point","title":"to_point","text":"<pre><code>to_point() -&gt; Point\n</code></pre> <p>Convert the vertex to a point.</p> <p>Returns:</p> <ul> <li> <code>Point</code>           \u2013            <p>The point.</p> </li> </ul>"},{"location":"api/compas_occ.conversions/","title":"Conversions","text":""},{"location":"api/compas_occ.conversions/#compas_occ.conversions","title":"compas_occ.conversions","text":""},{"location":"api/compas_occ.conversions/#compas_occ.conversions-functions","title":"Functions","text":""},{"location":"api/compas_occ.conversions/#compas_occ.conversions.aabb_to_compas","title":"aabb_to_compas","text":"<pre><code>aabb_to_compas(aabb: Bnd_Box) -&gt; Box\n</code></pre> <p>Convert an OCC oriented bounding box to a COMPAS box.</p>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.array1_from_floats1","title":"array1_from_floats1","text":"<pre><code>array1_from_floats1(numbers: list[float]) -&gt; TColStd_Array1OfReal\n</code></pre> <p>Construct a one-dimensional float array from a list of floats.</p> See Also <ul> <li><code>array1_from_integers1</code></li> <li><code>array2_from_floats2</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas_occ.conversions import array1_from_floats1\n&gt;&gt;&gt; floats1 = [0.0, 1.0, 2.0]\n&gt;&gt;&gt; array1 = array1_from_floats1(floats1)\n&gt;&gt;&gt; array1\n&lt;OCC.Core.TColStd.TColStd_Array1OfReal; ... &gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.array1_from_integers1","title":"array1_from_integers1","text":"<pre><code>array1_from_integers1(numbers: list[int]) -&gt; TColStd_Array1OfInteger\n</code></pre> <p>Construct a one-dimensional integer array from a list of integers.</p> See Also <ul> <li><code>array1_from_floats1</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas_occ.conversions import array1_from_integers1\n&gt;&gt;&gt; integers1 = [0, 1, 2]\n&gt;&gt;&gt; array1 = array1_from_integers1(integers1)\n&gt;&gt;&gt; array1\n&lt;OCC.Core.TColStd.TColStd_Array1OfInteger; ... &gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.array1_from_points1","title":"array1_from_points1","text":"<pre><code>array1_from_points1(points: list[Point]) -&gt; TColgp_Array1OfPnt\n</code></pre> <p>Construct a one-dimensional point array from a list of points.</p> See Also <ul> <li><code>harray1_from_points1</code></li> <li><code>points1_from_array1</code></li> <li><code>compas_occ.conversions.point_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.conversions import array1_from_points1\n</code></pre> <pre><code>&gt;&gt;&gt; points1 = [Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0)]\n&gt;&gt;&gt; array1 = array1_from_points1(points1)\n&gt;&gt;&gt; array1\n&lt;OCC.Core.TColgp.TColgp_Array1OfPnt; ... &gt;\n</code></pre> <pre><code>&gt;&gt;&gt; for item in array1:\n...     print(item)\n&lt;class 'gp_Pnt'&gt;\n&lt;class 'gp_Pnt'&gt;\n&lt;class 'gp_Pnt'&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; for item in array1:\n...     print(item.X(), item.Y(), item.Z())\n0.0 0.0 0.0\n1.0 0.0 0.0\n2.0 0.0 0.0\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.array2_from_floats2","title":"array2_from_floats2","text":"<pre><code>array2_from_floats2(numbers: list[list[float]]) -&gt; TColStd_Array2OfReal\n</code></pre> <p>Construct a two-dimensional real array from a list of lists of floats.</p> See Also <ul> <li><code>array1_from_floats1</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas_occ.conversions import array2_from_floats2\n&gt;&gt;&gt; floats2 = [\n...     [0.0, 0.0, 0.0],\n...     [1.0, 0.0, 0.0],\n...     [2.0, 0.0, 0.0],\n... ]\n&gt;&gt;&gt; array2 = array2_from_floats2(floats2)\n&gt;&gt;&gt; array2\n&lt;OCC.Core.TColStd.TColStd_Array2OfReal; ... &gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.array2_from_points2","title":"array2_from_points2","text":"<pre><code>array2_from_points2(points: list[list[Point]]) -&gt; TColgp_Array2OfPnt\n</code></pre> <p>Construct a two-dimensional point array from a list of lists of points.</p> See Also <ul> <li><code>points2_from_array2</code></li> <li><code>compas_occ.conversions.point_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.conversions import array2_from_points2\n</code></pre> <pre><code>&gt;&gt;&gt; points2 = [\n...     [Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0)],\n...     [Point(0, 1, 0), Point(1, 1, 0), Point(2, 1, 0)],\n... ]\n&gt;&gt;&gt; array2 = array2_from_points2(points2)\n&gt;&gt;&gt; array2\n&lt;OCC.Core.TColgp.TColgp_Array2OfPnt; ... &gt;\n</code></pre> <pre><code>&gt;&gt;&gt; rows = range(array2.LowerRow(), array2.UpperRow() + 1)\n&gt;&gt;&gt; cols = range(array2.LowerCol(), array2.UpperCol() + 1)\n&gt;&gt;&gt; for i, j in product(rows, cols):\n...     value = array2.Value(i, j)\n...     x = value.X()\n...     y = value.Y()\n...     z = value.Z()\n...     print(x, y, z)\n0.0 0.0 0.0\n0.0 1.0 0.0\n1.0 0.0 0.0\n1.0 1.0 0.0\n2.0 0.0 0.0\n2.0 1.0 0.0\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ax22d_to_compas","title":"ax22d_to_compas","text":"<pre><code>ax22d_to_compas(position: gp_Ax22d, cls: Type[Frame] | None = None) -&gt; Frame\n</code></pre> <p>Construct a COMPAS frame from a 2D OCC position.</p> See Also <ul> <li>ax3_to_compas</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d\n&gt;&gt;&gt; from compas_occ.conversions import ax22d_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax22d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1), gp_Dir2d(1, 0))\n&gt;&gt;&gt; ax22d_to_compas(ax2)\nFrame(point=Point(x=0.0, y=0.0, z=0.0), xaxis=Vector(x=0.0, y=1.0, z=0.0), yaxis=Vector(x=1.0, y=0.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ax2_to_compas","title":"ax2_to_compas","text":"<pre><code>ax2_to_compas(position: gp_Ax2, cls: Type[Frame] | None = None) -&gt; Frame\n</code></pre> <p>Construct a COMPAS frame from an OCC position.</p> See Also <ul> <li>ax3_to_compas</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2\n&gt;&gt;&gt; from compas_occ.conversions import ax2_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax2(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; ax2_to_compas(ax2)\nFrame(point=Point(x=0.0, y=0.0, z=0.0), xaxis=Vector(x=1.0, y=0.0, z=0.0), yaxis=Vector(x=0.0, y=1.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ax3_to_compas","title":"ax3_to_compas","text":"<pre><code>ax3_to_compas(position: gp_Ax3, cls: Type[Frame] | None = None) -&gt; Frame\n</code></pre> <p>Construct a COMPAS frame from an OCC position.</p> See Also <ul> <li><code>ax2_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax3\n&gt;&gt;&gt; from compas_occ.conversions import ax3_to_compas\n&gt;&gt;&gt; ax3 = gp_Ax3(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; ax3_to_compas(ax3)\nFrame(point=Point(x=0.0, y=0.0, z=0.0), xaxis=Vector(x=1.0, y=0.0, z=0.0), yaxis=Vector(x=0.0, y=1.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.axis2d_to_compas","title":"axis2d_to_compas","text":"<pre><code>axis2d_to_compas(axis: gp_Ax2d) -&gt; tuple[Point, Vector]\n</code></pre> <p>Convert a 2D OCC axis to a tuple of COMPAS point and vector.</p> See Also <ul> <li>axis_to_compas_vector</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax2d\n&gt;&gt;&gt; from compas_occ.conversions import axis2d_to_compas\n&gt;&gt;&gt; axis = gp_Ax2d(gp_Pnt2d(0, 0), gp_Dir2d(1, 0))\n&gt;&gt;&gt; axis2d_to_compas(axis)\n(Point(x=0.0, y=0.0, z=0.0), Vector(x=1.0, y=0.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.axis2d_to_compas_vector","title":"axis2d_to_compas_vector","text":"<pre><code>axis2d_to_compas_vector(axis: gp_Ax2d, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Convert a 2D OCC axis to a COMPAS vector.</p> See Also <ul> <li>direction_to_compas</li> <li>vector_to_compas</li> <li>vector2d_to_compas</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax1\n&gt;&gt;&gt; from compas_occ.conversions import axis_to_compas_vector\n&gt;&gt;&gt; axis = gp_Ax2d(gp_Pnt2d(0, 0), gp_Dir2d(1, 0))\n&gt;&gt;&gt; axis2d_to_compas_vector(axis)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.axis_to_compas","title":"axis_to_compas","text":"<pre><code>axis_to_compas(axis: gp_Ax1) -&gt; tuple[Point, Vector]\n</code></pre> <p>Convert an OCC axis to a tuple of COMPAS point and vector.</p> See Also <ul> <li>axis_to_compas_vector</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax1\n&gt;&gt;&gt; from compas_occ.conversions import axis_to_compas\n&gt;&gt;&gt; axis = gp_Ax1(gp_Pnt(0, 0, 0), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; axis_to_compas(axis)\n(Point(x=0.0, y=0.0, z=0.0), Vector(x=1.0, y=0.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.axis_to_compas_vector","title":"axis_to_compas_vector","text":"<pre><code>axis_to_compas_vector(axis: gp_Ax1, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Convert an OCC axis to a COMPAS vector.</p> See Also <ul> <li>direction_to_compas</li> <li>vector_to_compas</li> <li>vector2d_to_compas</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax1\n&gt;&gt;&gt; from compas_occ.conversions import axis_to_compas_vector\n&gt;&gt;&gt; axis = gp_Ax1(gp_Pnt(0, 0, 0), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; axis_to_compas_vector(axis)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.axis_to_occ","title":"axis_to_occ","text":"<pre><code>axis_to_occ(axis: tuple[Point, Vector]) -&gt; gp_Ax1\n</code></pre> <p>Convert a COMPAS point and vector to an OCC axis.</p> See Also <ul> <li><code>line_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point, Vector\n&gt;&gt;&gt; from compas_occ.conversions import axis_to_occ\n&gt;&gt;&gt; point = Point(0, 0, 0)\n&gt;&gt;&gt; vector = Vector(1, 0, 0)\n&gt;&gt;&gt; axis_to_occ((point, vector))\n&lt;class 'gp_Ax1'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.bezier_to_compas","title":"bezier_to_compas","text":"<pre><code>bezier_to_compas(bezier: Geom_BezierCurve) -&gt; Bezier\n</code></pre> <p>Construct a COMPAS Bezier curve from an OCC Bezier curve.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Parab\n&gt;&gt;&gt; from compas_occ.conversions import bezier_to_compas\n&gt;&gt;&gt; from OCC.Core.Geom import Geom_BezierCurve\n&gt;&gt;&gt; from OCC.Core.TColgp import TColgp_Array1OfPnt\n&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt\n&gt;&gt;&gt; array = TColgp_Array1OfPnt(1, 4)\n&gt;&gt;&gt; array.SetValue(1, gp_Pnt(0, 0, 0))\n&gt;&gt;&gt; array.SetValue(2, gp_Pnt(1, 0, 0))\n&gt;&gt;&gt; array.SetValue(3, gp_Pnt(1, 1, 0))\n&gt;&gt;&gt; array.SetValue(4, gp_Pnt(0, 1, 0))\n&gt;&gt;&gt; bezier = Geom_BezierCurve(array)\n&gt;&gt;&gt; bezier_to_compas(bezier)\nBezier(points=[...])\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.bspline_to_compas","title":"bspline_to_compas","text":"<pre><code>bspline_to_compas(bspline: Geom_BSplineCurve) -&gt; NurbsCurve\n</code></pre> <p>Construct a COMPAS NURBS curve from an OCC B-spline curve.</p>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.circle2d_to_compas","title":"circle2d_to_compas","text":"<pre><code>circle2d_to_compas(circ: gp_Circ2d, cls: Type[Circle] | None = None) -&gt; Circle\n</code></pre> <p>Construct a COMPAS circle from a 2D OCC circle.</p> See Also <ul> <li><code>ellipse2d_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d, gp_Circ2d\n&gt;&gt;&gt; from compas_occ.conversions import circle2d_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax22d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1), gp_Dir2d(1, 0))\n&gt;&gt;&gt; circ = gp_Circ2d(ax2, 1)\n&gt;&gt;&gt; circle2d_to_compas(circ)\nCircle(radius=1.0, frame=Frame(...)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.circle_to_compas","title":"circle_to_compas","text":"<pre><code>circle_to_compas(circ: gp_Circ, cls: Type[Circle] | None = None) -&gt; Circle\n</code></pre> <p>Construct a COMPAS circle from an OCC circle.</p> See Also <ul> <li><code>ellipse_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Circ\n&gt;&gt;&gt; from compas_occ.conversions import circle_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax2(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; circ = gp_Circ(ax2, 1)\n&gt;&gt;&gt; circle_to_compas(circ)\nCircle(radius=1.0, frame=Frame(...)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.circle_to_occ","title":"circle_to_occ","text":"<pre><code>circle_to_occ(circle: Circle) -&gt; gp_Circ\n</code></pre> <p>Construct an OCC circle from a COMPAS circle.</p> See Also <ul> <li><code>ellipse_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Circle\n&gt;&gt;&gt; from compas_occ.conversions import circle_to_occ\n&gt;&gt;&gt; circle = Circle(1)\n&gt;&gt;&gt; circle_to_occ(circle)\n&lt;class 'gp_Circ'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.circle_to_occ2d","title":"circle_to_occ2d","text":"<pre><code>circle_to_occ2d(circle: Circle) -&gt; gp_Circ2d\n</code></pre> <p>Convert a COMPAS circle to a 2D OCC circle.</p> See Also <ul> <li><code>ellipse_to_occ2d</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Circle\n&gt;&gt;&gt; from compas_occ.conversions import circle_to_occ2d\n&gt;&gt;&gt; circle = Circle(1)\n&gt;&gt;&gt; circle_to_occ2d(circle)\n&lt;class 'gp_Circ2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.compas_mesh_to_occ_shell","title":"compas_mesh_to_occ_shell","text":"<pre><code>compas_mesh_to_occ_shell(mesh: Mesh) -&gt; TopoDS_Shell\n</code></pre> <p>Convert a general COMPAS mesh to an OCC shell.</p> See Also <ul> <li><code>compas_trimesh_to_occ_shell</code></li> <li><code>compas_quadmesh_to_occ_shell</code></li> </ul>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.compas_quadmesh_to_occ_shell","title":"compas_quadmesh_to_occ_shell","text":"<pre><code>compas_quadmesh_to_occ_shell(mesh: Mesh) -&gt; TopoDS_Shell\n</code></pre> <p>Convert a COMPAS quad mesh to an OCC shell.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the input mesh is not a quad mesh.</p> </li> </ul> See Also <ul> <li><code>compas_trimesh_to_occ_shell</code></li> <li><code>compas_mesh_to_occ_shell</code></li> </ul>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.compas_transformation_to_trsf","title":"compas_transformation_to_trsf","text":"<pre><code>compas_transformation_to_trsf(matrix: Transformation) -&gt; gp_Trsf\n</code></pre> <p>Convert a COMPAS transformation to a OCC transformation.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>Transformation</code>)           \u2013            <p>A COMPAS transformation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>gp_Trsf</code>           \u2013            <p>An OCC transformation.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Translation\n&gt;&gt;&gt; from compas_occ.conversions import compas_transformation_to_trsf\n&gt;&gt;&gt; transformation = Translation.from_vector([1, 2, 3])\n&gt;&gt;&gt; compas_transformation_to_trsf(transformation)\n&lt;class 'gp_Trsf'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.compas_trimesh_to_occ_shell","title":"compas_trimesh_to_occ_shell","text":"<pre><code>compas_trimesh_to_occ_shell(mesh: Mesh) -&gt; TopoDS_Shell\n</code></pre> <p>Convert a COMPAS triangle mesh to an OCC shell.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the mesh is not a triangle mesh.</p> </li> </ul> See Also <ul> <li><code>compas_quadmesh_to_occ_shell</code></li> <li><code>compas_mesh_to_occ_shell</code></li> </ul>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.cone_to_occ","title":"cone_to_occ","text":"<pre><code>cone_to_occ(cone: Cone) -&gt; gp_Cone\n</code></pre> <p>Convert a COMPAS cone to an OCC cone.</p> See Also <ul> <li><code>sphere_to_occ</code></li> <li><code>cylinder_to_occ</code></li> <li><code>torus_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Cone\n&gt;&gt;&gt; from compas_occ.conversions import cone_to_occ\n&gt;&gt;&gt; cone = Cone(1, 1)\n&gt;&gt;&gt; cone_to_occ(cone)\n&lt;class 'gp_Cone'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.cylinder_to_compas","title":"cylinder_to_compas","text":"<pre><code>cylinder_to_compas(\n    cylinder: gp_Cylinder, cls: Type[Cylinder] | None = None\n) -&gt; Cylinder\n</code></pre> <p>Convert an OCC cylinder to a COMPAS cylinder.</p> See Also <ul> <li>[<code>compas_sphere_from_occ_sphere</code>][]</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax3, gp_Cylinder\n&gt;&gt;&gt; from compas_occ.conversions import cylinder_to_compas\n&gt;&gt;&gt; ax3 = gp_Ax3(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; cylinder = gp_Cylinder(ax3, 1)\n&gt;&gt;&gt; cylinder_to_compas(cylinder)\nCylinder(radius=1.0, height=1.0, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.cylinder_to_occ","title":"cylinder_to_occ","text":"<pre><code>cylinder_to_occ(cylinder: Cylinder) -&gt; gp_Cylinder\n</code></pre> <p>Convert a COMPAS cylinder to an OCC cylinder.</p> See Also <ul> <li><code>sphere_to_occ</code></li> <li><code>cone_to_occ</code></li> <li><code>torus_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Cylinder\n&gt;&gt;&gt; from compas_occ.conversions import cylinder_to_occ\n&gt;&gt;&gt; cylinder = Cylinder(1, 1)\n&gt;&gt;&gt; cylinder_to_occ(cylinder)\n&lt;class 'gp_Cylinder'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.direction2d_to_compas","title":"direction2d_to_compas","text":"<pre><code>direction2d_to_compas(direction: gp_Dir2d, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Construct a COMPAS vector from a 2D OCC direction.</p> See Also <ul> <li><code>vector_to_compas</code></li> <li><code>vector2d_to_compas</code></li> <li><code>axis_to_compas_vector</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Dir2d\n&gt;&gt;&gt; from compas_occ.conversions import direction2d_to_compas\n&gt;&gt;&gt; vector = gp_Dir2d(1, 0)\n&gt;&gt;&gt; direction2d_to_compas(vector)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.direction_to_compas","title":"direction_to_compas","text":"<pre><code>direction_to_compas(vector: gp_Dir, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Construct a COMPAS vector from an OCC direction.</p> See Also <ul> <li><code>vector_to_compas</code></li> <li><code>vector2d_to_compas</code></li> <li><code>axis_to_compas_vector</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Dir\n&gt;&gt;&gt; from compas_occ.conversions import direction_to_compas\n&gt;&gt;&gt; vector = gp_Dir(1, 0, 0)\n&gt;&gt;&gt; direction_to_compas(vector)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.direction_to_occ","title":"direction_to_occ","text":"<pre><code>direction_to_occ(vector: Vector) -&gt; gp_Dir\n</code></pre> <p>Convert a COMPAS vector to an OCC direction.</p> See Also <ul> <li><code>vector_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Vector\n&gt;&gt;&gt; from compas_occ.conversions import direction_to_occ\n&gt;&gt;&gt; vector = Vector(1, 0, 0)\n&gt;&gt;&gt; direction_to_occ(vector)\n&lt;class 'gp_Dir'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.direction_to_occ2d","title":"direction_to_occ2d","text":"<pre><code>direction_to_occ2d(vector: Vector) -&gt; gp_Dir2d\n</code></pre> <p>Convert a COMPAS vector to a 2D OCC direction.</p> See Also <ul> <li><code>vector_to_occ2d</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Vector\n&gt;&gt;&gt; from compas_occ.conversions import direction_to_occ2d\n&gt;&gt;&gt; vector = Vector(1, 0, 0)\n&gt;&gt;&gt; direction_to_occ2d(vector)\n&lt;class 'gp_Dir2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ellipse2d_to_compas","title":"ellipse2d_to_compas","text":"<pre><code>ellipse2d_to_compas(elips: gp_Elips2d, cls: Type[Ellipse] | None = None) -&gt; Ellipse\n</code></pre> <p>Construc a COMPAS ellipse from a 2D OCC ellipse.</p> See Also <ul> <li><code>circle2d_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d, gp_Elips2d\n&gt;&gt;&gt; from compas_occ.conversions import ellipse_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax22d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1), gp_Dir2d(1, 0))\n&gt;&gt;&gt; elips = gp_Elips2d(ax2, 1, 0.5)\n&gt;&gt;&gt; ellipse2d_to_compas(elips)\nEllipse(major=1.0, minor=0.5, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ellipse_to_compas","title":"ellipse_to_compas","text":"<pre><code>ellipse_to_compas(elips: gp_Elips, cls: Type[Ellipse] | None = None) -&gt; Ellipse\n</code></pre> <p>Construc a COMPAS ellipse from an OCC ellipse.</p> See Also <ul> <li><code>circle_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Elips\n&gt;&gt;&gt; from compas_occ.conversions import ellipse_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax2(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; elips = gp_Elips(ax2, 1, 0.5)\n&gt;&gt;&gt; ellipse_to_compas(elips)\nEllipse(major=1.0, minor=0.5, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ellipse_to_occ","title":"ellipse_to_occ","text":"<pre><code>ellipse_to_occ(ellipse: Ellipse) -&gt; gp_Elips\n</code></pre> <p>Construct an OCC ellipse from a COMPAS ellipse.</p> See Also <ul> <li><code>circle_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Ellipse\n&gt;&gt;&gt; from compas_occ.conversions import ellipse_to_occ\n&gt;&gt;&gt; ellipse = Ellipse(1, 0.5)\n&gt;&gt;&gt; ellipse_to_occ(ellipse)\n&lt;class 'gp_Elips'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ellipse_to_occ2d","title":"ellipse_to_occ2d","text":"<pre><code>ellipse_to_occ2d(ellipse: Ellipse) -&gt; gp_Elips2d\n</code></pre> <p>Convert a COMPAS ellipse to a 2D OCC ellipse.</p> See Also <ul> <li><code>circle_to_occ2d</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Ellipse\n&gt;&gt;&gt; from compas_occ.conversions import ellipse_to_occ2d\n&gt;&gt;&gt; ellipse = Ellipse(1, 0.5)\n&gt;&gt;&gt; ellipse_to_occ2d(ellipse)\n&lt;class 'gp_Elips2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.floats2_from_array2","title":"floats2_from_array2","text":"<pre><code>floats2_from_array2(array: TColStd_Array2OfReal) -&gt; list[Sequence[float]]\n</code></pre> <p>Construct a list of lists of floats from a two-dimensional array of real numbers.</p> See Also <ul> <li><code>array2_from_floats2</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt; from OCC.Core.TColStd import TColStd_Array2OfReal\n</code></pre> <pre><code>&gt;&gt;&gt; array2 = TColStd_Array2OfReal(1, 2, 1, 3)\n&gt;&gt;&gt; array2.SetValue(1, 1, 0.0)\n&gt;&gt;&gt; array2.SetValue(1, 2, 1.0)\n&gt;&gt;&gt; array2.SetValue(1, 3, 2.0)\n&gt;&gt;&gt; array2.SetValue(2, 1, 0.0)\n&gt;&gt;&gt; array2.SetValue(2, 2, 1.0)\n&gt;&gt;&gt; array2.SetValue(2, 3, 2.0)\n</code></pre> <pre><code>&gt;&gt;&gt; floats2 = floats2_from_array2(array2)\n&gt;&gt;&gt; floats2\n[(0.0, 0.0), (1.0, 1.0), (2.0, 2.0)]\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.frame_to_occ_ax2","title":"frame_to_occ_ax2","text":"<pre><code>frame_to_occ_ax2(frame: Frame) -&gt; gp_Ax2\n</code></pre> <p>Convert a COMPAS frame to a right-handed OCC coordinate system.</p> See Also <ul> <li><code>frame_to_occ_ax3</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Frame\n&gt;&gt;&gt; from compas_occ.conversions import frame_to_occ_ax2\n&gt;&gt;&gt; frame = Frame.worldXY()\n&gt;&gt;&gt; frame_to_occ_ax2(frame)\n&lt;class 'gp_Ax2'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.frame_to_occ_ax22d","title":"frame_to_occ_ax22d","text":"<pre><code>frame_to_occ_ax22d(frame: Frame) -&gt; gp_Ax22d\n</code></pre> <p>Convert a COMPAS frame to a 2D right-handed OCC coordinate system.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Frame\n&gt;&gt;&gt; from compas_occ.conversions import frame_to_occ_ax22d\n&gt;&gt;&gt; frame = Frame.worldXY()\n&gt;&gt;&gt; frame_to_occ_ax22d(frame)\n&lt;class 'gp_Ax22d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.frame_to_occ_ax3","title":"frame_to_occ_ax3","text":"<pre><code>frame_to_occ_ax3(frame: Frame) -&gt; gp_Ax3\n</code></pre> <p>Convert a COMPAS frame to a right-handed OCC coordinate system.</p> See Also <ul> <li><code>frame_to_occ_ax2</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Frame\n&gt;&gt;&gt; from compas_occ.conversions import frame_to_occ_ax3\n&gt;&gt;&gt; frame = Frame.worldXY()\n&gt;&gt;&gt; frame_to_occ_ax3(frame)\n&lt;class 'gp_Ax3'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.harray1_from_points1","title":"harray1_from_points1","text":"<pre><code>harray1_from_points1(points: list[Point]) -&gt; TColgp_HArray1OfPnt\n</code></pre> <p>Construct a horizontal one-dimensional point array from a list of points.</p> See Also <ul> <li><code>array1_from_points1</code></li> <li><code>compas_occ.conversions.point_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.conversions import harray1_from_points1\n</code></pre> <pre><code>&gt;&gt;&gt; points1 = [Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0)]\n&gt;&gt;&gt; harray1 = harray1_from_points1(points1)\n&gt;&gt;&gt; harray1\n&lt;OCC.Core.TColgp.TColgp_HArray1OfPnt; ... &gt;\n</code></pre> <pre><code>&gt;&gt;&gt; for item in harray1:\n...     print(item)\n&lt;class 'gp_Pnt'&gt;\n&lt;class 'gp_Pnt'&gt;\n&lt;class 'gp_Pnt'&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; for item in harray1:\n...     print(item.X(), item.Y(), item.Z())\n0.0 0.0 0.0\n1.0 0.0 0.0\n2.0 0.0 0.0\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.hyperbola2d_to_compas","title":"hyperbola2d_to_compas","text":"<pre><code>hyperbola2d_to_compas(hypr: gp_Hypr2d) -&gt; Hyperbola\n</code></pre> <p>Construct a COMPAS hyperbola from a 2D OCC hyperbola.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d, gp_Hypr2d\n&gt;&gt;&gt; from compas_occ.conversions import hyperbola_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax22d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1), gp_Dir2d(1, 0))\n&gt;&gt;&gt; hypr = gp_Hypr2d(ax2, 1, 0.5)\n&gt;&gt;&gt; hyperbola2d_to_compas(hypr)\nHyperbola(major=1.0, minor=0.5, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.hyperbola_to_compas","title":"hyperbola_to_compas","text":"<pre><code>hyperbola_to_compas(hypr: gp_Hypr) -&gt; Hyperbola\n</code></pre> <p>Construct a COMPAS hyperbola from an OCC hyperbola.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Hypr\n&gt;&gt;&gt; from compas_occ.conversions import hyperbola_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax2(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; hypr = gp_Hypr(ax2, 1, 0.5)\n&gt;&gt;&gt; hyperbola_to_compas(hypr)\nHyperbola(major=1.0, minor=0.5, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.line2d_to_compas","title":"line2d_to_compas","text":"<pre><code>line2d_to_compas(lin: gp_Lin2d, cls: Type[Line] | None = None) -&gt; Line\n</code></pre> <p>Convert a 2D OCC line to a COMPAS line.</p> See Also <p><code>line_to_occ2d</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Lin2d\n&gt;&gt;&gt; from compas_occ.conversions import line2d_to_compas\n&gt;&gt;&gt; line = gp_Lin2d(gp_Pnt2d(0, 0), gp_Dir2d(1, 0))\n&gt;&gt;&gt; line2d_to_compas(line)\nLine(Point(x=0.0, y=0.0, z=0.0), Point(x=1.0, y=0.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.line_to_compas","title":"line_to_compas","text":"<pre><code>line_to_compas(lin: gp_Lin, cls: Type[Line] | None = None) -&gt; Line\n</code></pre> <p>Convert an OCC line to a COMPAS line.</p> See Also <ul> <li><code>line_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Lin\n&gt;&gt;&gt; from compas_occ.conversions import line_to_compas\n&gt;&gt;&gt; line = gp_Lin(gp_Pnt(0, 0, 0), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; line_to_compas(line)\nLine(Point(x=0.0, y=0.0, z=0.0), Point(x=1.0, y=0.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.line_to_occ","title":"line_to_occ","text":"<pre><code>line_to_occ(line: Line) -&gt; gp_Lin\n</code></pre> <p>Convert a COMPAS line to an OCC line.</p> See Also <ul> <li><code>axis_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Line\n&gt;&gt;&gt; from compas_occ.conversions import line_to_occ\n&gt;&gt;&gt; line = Line([0, 0, 0], [1, 0, 0])\n&gt;&gt;&gt; line_to_occ(line)\n&lt;class 'gp_Lin'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.line_to_occ2d","title":"line_to_occ2d","text":"<pre><code>line_to_occ2d(line: Line) -&gt; gp_Lin2d\n</code></pre> <p>Convert a COMPAS line to a 2D OCC line.</p> See Also <ul> <li>[<code>axis_to_occ2d</code>][]</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Line\n&gt;&gt;&gt; from compas_occ.conversions import line_to_occ2d\n&gt;&gt;&gt; line = Line([0, 0, 0], [1, 0, 0])\n&gt;&gt;&gt; line_to_occ2d(line)\n&lt;class 'gp_Lin2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.location_to_compas","title":"location_to_compas","text":"<pre><code>location_to_compas(location: TopLoc_Location) -&gt; Frame\n</code></pre> <p>Construct a COMPAS frame from an OCC location.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.TopLoc import TopLoc_Location\n&gt;&gt;&gt; from compas_occ.conversions import location_to_compas\n&gt;&gt;&gt; location = TopLoc_Location()\n&gt;&gt;&gt; location_to_compas(location)\nFrame(point=Point(x=0.0, y=0.0, z=0.0), xaxis=Vector(x=1.0, y=0.0, z=0.0), yaxis=Vector(x=0.0, y=1.0, z=0.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.ngon_to_face","title":"ngon_to_face","text":"<pre><code>ngon_to_face(ngon: NGon) -&gt; TopoDS_Face\n</code></pre> <p>Convert a Ngon to a BRep face with an underlying best-fit surface.</p> See Also <ul> <li><code>triangle_to_face</code></li> <li><code>quad_to_face</code></li> </ul>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.obb_to_compas","title":"obb_to_compas","text":"<pre><code>obb_to_compas(obb: Bnd_OBB) -&gt; Box\n</code></pre> <p>Convert an OCC oriented bounding box to a COMPAS box.</p>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.parabola2d_to_compas","title":"parabola2d_to_compas","text":"<pre><code>parabola2d_to_compas(parab: gp_Parab2d) -&gt; Parabola\n</code></pre> <p>Construct a COMPAS parabola from a 2D OCC parabola.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d, gp_Dir2d, gp_Ax22d, gp_Parab2d\n&gt;&gt;&gt; from compas_occ.conversions import parabola_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax22d(gp_Pnt2d(0, 0), gp_Dir2d(0, 1), gp_Dir2d(1, 0))\n&gt;&gt;&gt; parab = gp_Parab2d(ax2, 1)\n&gt;&gt;&gt; parabola2d_to_compas(parab)\nParabola(focal=2.0, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.parabola_to_compas","title":"parabola_to_compas","text":"<pre><code>parabola_to_compas(parab: gp_Parab) -&gt; Parabola\n</code></pre> <p>Construct a COMPAS parabola from an OCC parabola.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax2, gp_Parab\n&gt;&gt;&gt; from compas_occ.conversions import parabola_to_compas\n&gt;&gt;&gt; ax2 = gp_Ax2(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; parab = gp_Parab(ax2, 1)\n&gt;&gt;&gt; parabola_to_compas(parab)\nParabola(focal=2.0, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.plane_to_compas","title":"plane_to_compas","text":"<pre><code>plane_to_compas(pln: gp_Pln, cls: Type[Plane] | None = None) -&gt; Plane\n</code></pre> <p>Convert an OCC plane to a COMPAS plane.</p> See Also <ul> <li><code>plane_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Pln\n&gt;&gt;&gt; from compas_occ.conversions import plane_to_compas\n&gt;&gt;&gt; plane = gp_Pln(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1))\n&gt;&gt;&gt; plane_to_compas(plane)\nPlane(point=Point(x=0.0, y=0.0, z=0.0), normal=Vector(x=0.0, y=0.0, z=1.0))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.plane_to_occ","title":"plane_to_occ","text":"<pre><code>plane_to_occ(plane: Plane) -&gt; gp_Pln\n</code></pre> <p>Convert a COMPAS plane to an OCC plane.</p> See Also <ul> <li><code>plane_to_occ_ax2</code></li> <li><code>plane_to_occ_ax3</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Plane\n&gt;&gt;&gt; from compas_occ.conversions import plane_to_occ\n&gt;&gt;&gt; plane = Plane([0, 0, 0], [0, 0, 1])\n&gt;&gt;&gt; plane_to_occ(plane)\n&lt;class 'gp_Pln'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.plane_to_occ_ax2","title":"plane_to_occ_ax2","text":"<pre><code>plane_to_occ_ax2(plane: Plane) -&gt; gp_Ax2\n</code></pre> <p>Convert a COMPAS plane to a right-handed OCC coordinate system.</p> See Also <ul> <li><code>plane_to_occ</code></li> <li><code>plane_to_occ_ax3</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Plane\n&gt;&gt;&gt; from compas_occ.conversions import plane_to_occ_ax2\n&gt;&gt;&gt; plane = Plane([0, 0, 0], [0, 0, 1])\n&gt;&gt;&gt; plane_to_occ_ax2(plane)\n&lt;class 'gp_Ax2'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.plane_to_occ_ax3","title":"plane_to_occ_ax3","text":"<pre><code>plane_to_occ_ax3(plane: Plane) -&gt; gp_Ax3\n</code></pre> <p>Convert a COMPAS plane to a right-handed OCC coordinate system.</p> See Also <ul> <li><code>plane_to_occ</code></li> <li><code>plane_to_occ_ax2</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Plane\n&gt;&gt;&gt; from compas_occ.conversions import plane_to_occ_ax3\n&gt;&gt;&gt; plane = Plane([0, 0, 0], [0, 0, 1])\n&gt;&gt;&gt; plane_to_occ_ax3(plane)\n&lt;class 'gp_Ax3'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.point2d_to_compas","title":"point2d_to_compas","text":"<pre><code>point2d_to_compas(point: gp_Pnt2d, cls: Type[Point] | None = None) -&gt; Point\n</code></pre> <p>Construct a COMPAS point from an OCC 2D point.</p> See Also <ul> <li><code>point_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt2d\n&gt;&gt;&gt; from compas_occ.conversions import point2d_to_compas\n&gt;&gt;&gt; point = gp_Pnt2d(0, 0)\n&gt;&gt;&gt; point2d_to_compas(point)\nPoint(x=0.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.point_to_compas","title":"point_to_compas","text":"<pre><code>point_to_compas(point: gp_Pnt, cls: Type[Point] | None = None) -&gt; Point\n</code></pre> <p>Construct a COMPAS point from an OCC point.</p> See Also <ul> <li><code>point2d_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt\n&gt;&gt;&gt; from compas_occ.conversions import point_to_compas\n&gt;&gt;&gt; point = gp_Pnt(0, 0, 0)\n&gt;&gt;&gt; point_to_compas(point)\nPoint(x=0.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.point_to_occ","title":"point_to_occ","text":"<pre><code>point_to_occ(point: Point) -&gt; gp_Pnt\n</code></pre> <p>Convert a COMPAS point to an OCC point.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.conversions import point_to_occ\n&gt;&gt;&gt; point = Point(0, 0, 0)\n&gt;&gt;&gt; point_to_occ(point)\n&lt;class 'gp_Pnt'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.point_to_occ2d","title":"point_to_occ2d","text":"<pre><code>point_to_occ2d(point: Point) -&gt; gp_Pnt2d\n</code></pre> <p>Convert a COMPAS point to a 2D OCC point.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.conversions import point_to_occ2d\n&gt;&gt;&gt; point = Point(0, 0, 0)\n&gt;&gt;&gt; point_to_occ2d(point)\n&lt;class 'gp_Pnt2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.points1_from_array1","title":"points1_from_array1","text":"<pre><code>points1_from_array1(array: TColgp_Array1OfPnt) -&gt; list[Point]\n</code></pre> <p>Construct a list of points from a one-dimensional point array.</p> See Also <ul> <li><code>array1_from_points1</code></li> <li><code>compas_occ.conversions.point_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas_occ.conversions import points1_from_array1\n&gt;&gt;&gt; from OCC.Core.TColgp import TColgp_Array1OfPnt\n&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt\n</code></pre> <pre><code>&gt;&gt;&gt; array1 = TColgp_Array1OfPnt(1, 3)\n&gt;&gt;&gt; array1.SetValue(1, gp_Pnt(0, 0, 0))\n&gt;&gt;&gt; array1.SetValue(2, gp_Pnt(1, 0, 0))\n&gt;&gt;&gt; array1.SetValue(3, gp_Pnt(2, 0, 0))\n</code></pre> <pre><code>&gt;&gt;&gt; points1 = points1_from_array1(array1)\n&gt;&gt;&gt; for point in points1:\n...     print(point)\nPoint(x=0.0, y=0.0, z=0.0)\nPoint(x=1.0, y=0.0, z=0.0)\nPoint(x=2.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.points2_from_array2","title":"points2_from_array2","text":"<pre><code>points2_from_array2(array: TColgp_Array2OfPnt) -&gt; list[list[Point]]\n</code></pre> <p>Construct a list of lists of points from two-dimensional point array.</p> See Also <ul> <li><code>array2_from_points2</code></li> <li><code>compas_occ.conversions.point_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from itertools import product\n&gt;&gt;&gt; from OCC.Core.TColgp import TColgp_Array2OfPnt\n&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt\n</code></pre> <pre><code>&gt;&gt;&gt; array2 = TColgp_Array2OfPnt(1, 2, 1, 3)\n&gt;&gt;&gt; array2.SetValue(1, 1, gp_Pnt(0, 0, 0))\n&gt;&gt;&gt; array2.SetValue(1, 2, gp_Pnt(1, 0, 0))\n&gt;&gt;&gt; array2.SetValue(1, 3, gp_Pnt(2, 0, 0))\n&gt;&gt;&gt; array2.SetValue(2, 1, gp_Pnt(0, 1, 0))\n&gt;&gt;&gt; array2.SetValue(2, 2, gp_Pnt(1, 1, 0))\n&gt;&gt;&gt; array2.SetValue(2, 3, gp_Pnt(2, 1, 0))\n</code></pre> <pre><code>&gt;&gt;&gt; points2 = points2_from_array2(array2)\n&gt;&gt;&gt; rows = len(points2)\n&gt;&gt;&gt; cols = len(points2[0])\n&gt;&gt;&gt; for i, j in product(range(rows), range(cols)):\n...     print(points2[i][j])\nPoint(x=0.0, y=0.0, z=0.0)\nPoint(x=0.0, y=1.0, z=0.0)\nPoint(x=1.0, y=0.0, z=0.0)\nPoint(x=1.0, y=1.0, z=0.0)\nPoint(x=2.0, y=0.0, z=0.0)\nPoint(x=2.0, y=1.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.quad_to_face","title":"quad_to_face","text":"<pre><code>quad_to_face(quad: Quad) -&gt; TopoDS_Face\n</code></pre> <p>Convert a quad to a BRep face with an underlying ruled surface.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of points is not 4.</p> </li> </ul> See Also <ul> <li><code>triangle_to_face</code></li> <li><code>ngon_to_face</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; quad = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0]]\n&gt;&gt;&gt; quad_to_face(quad)\n&lt;class 'TopoDS_Face'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.sphere_to_compas","title":"sphere_to_compas","text":"<pre><code>sphere_to_compas(sphere: gp_Sphere, cls: Type[Sphere] | None = None) -&gt; Sphere\n</code></pre> <p>Convert an OCC sphere to a COMPAS sphere.</p> See Also <ul> <li><code>cylinder_to_compas</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Pnt, gp_Dir, gp_Ax3, gp_Sphere\n&gt;&gt;&gt; from compas_occ.conversions import sphere_to_compas\n&gt;&gt;&gt; ax3 = gp_Ax3(gp_Pnt(0, 0, 0), gp_Dir(0, 0, 1), gp_Dir(1, 0, 0))\n&gt;&gt;&gt; sphere = gp_Sphere(ax3, 1)\n&gt;&gt;&gt; sphere_to_compas(sphere)\nSphere(radius=1.0, frame=Frame(...))\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.sphere_to_occ","title":"sphere_to_occ","text":"<pre><code>sphere_to_occ(sphere: Sphere) -&gt; gp_Sphere\n</code></pre> <p>Convert a COMPAS sphere to an OCC sphere.</p> See Also <ul> <li><code>cylinder_to_occ</code></li> <li><code>cone_to_occ</code></li> <li><code>torus_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Sphere\n&gt;&gt;&gt; from compas_occ.conversions import sphere_to_occ\n&gt;&gt;&gt; sphere = Sphere(1)\n&gt;&gt;&gt; sphere_to_occ(sphere)\n&lt;class 'gp_Sphere'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.torus_to_occ","title":"torus_to_occ","text":"<pre><code>torus_to_occ(torus: Torus) -&gt; gp_Torus\n</code></pre> <p>Convert a COMPAS torus to an OCC torus.</p> See Also <ul> <li><code>sphere_to_occ</code></li> <li><code>cylinder_to_occ</code></li> <li><code>cone_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Torus\n&gt;&gt;&gt; from compas_occ.conversions import torus_to_occ\n&gt;&gt;&gt; torus = Torus(1, 0.5)\n&gt;&gt;&gt; torus_to_occ(torus)\n&lt;class 'gp_Torus'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.triangle_to_face","title":"triangle_to_face","text":"<pre><code>triangle_to_face(triangle: Triangle) -&gt; TopoDS_Face\n</code></pre> <p>Convert a triangle to a BRep face.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the number of points is not 3.</p> </li> </ul> See Also <ul> <li><code>quad_to_face</code></li> <li><code>ngon_to_face</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; triangle = [[0, 0, 0], [1, 0, 0], [0, 1, 0]]\n&gt;&gt;&gt; triangle_to_face(triangle)\n&lt;class 'TopoDS_Face'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.vector2d_to_compas","title":"vector2d_to_compas","text":"<pre><code>vector2d_to_compas(vector: gp_Vec2d, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Construct a COMPAS vector from an OCC 2D vector.</p> See Also <ul> <li><code>vector_to_compas</code></li> <li><code>direction_to_compas</code></li> <li><code>axis_to_compas_vector</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Vec2d\n&gt;&gt;&gt; from compas_occ.conversions import vector2d_to_compas\n&gt;&gt;&gt; vector = gp_Vec2d(1, 0)\n&gt;&gt;&gt; vector2d_to_compas(vector)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.vector_to_compas","title":"vector_to_compas","text":"<pre><code>vector_to_compas(vector: gp_Vec, cls: Type[Vector] | None = None) -&gt; Vector\n</code></pre> <p>Construct a COMPAS vector from an OCC vector.</p> See Also <ul> <li><code>vector2d_to_compas</code></li> <li><code>direction_to_compas</code></li> <li><code>axis_to_compas_vector</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from OCC.Core.gp import gp_Vec\n&gt;&gt;&gt; from compas_occ.conversions import vector_to_compas\n&gt;&gt;&gt; vector = gp_Vec(1, 0, 0)\n&gt;&gt;&gt; vector_to_compas(vector)\nVector(x=1.0, y=0.0, z=0.0)\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.vector_to_occ","title":"vector_to_occ","text":"<pre><code>vector_to_occ(vector: Vector) -&gt; gp_Vec\n</code></pre> <p>Convert a COMPAS vector to an OCC vector.</p> See Also <ul> <li><code>direction_to_occ</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Vector\n&gt;&gt;&gt; from compas_occ.conversions import vector_to_occ\n&gt;&gt;&gt; vector = Vector(1, 0, 0)\n&gt;&gt;&gt; vector_to_occ(vector)\n&lt;class 'gp_Vec'&gt;\n</code></pre>"},{"location":"api/compas_occ.conversions/#compas_occ.conversions.vector_to_occ2d","title":"vector_to_occ2d","text":"<pre><code>vector_to_occ2d(vector: Vector) -&gt; gp_Vec2d\n</code></pre> <p>Convert a COMPAS vector to a 2D OCC vector.</p> See Also <ul> <li><code>direction_to_occ2d</code></li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Vector\n&gt;&gt;&gt; from compas_occ.conversions import vector_to_occ2d\n&gt;&gt;&gt; vector = Vector(1, 0, 0)\n&gt;&gt;&gt; vector_to_occ2d(vector)\n&lt;class 'gp_Vec2d'&gt;\n</code></pre>"},{"location":"api/compas_occ.geometry.OCCCurve/","title":"OCCCurve","text":""},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve","title":"OCCCurve","text":"<pre><code>OCCCurve(native_curve: Geom_Curve, name=None)\n</code></pre> <p>Class representing a general curve object.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom_Curve</code>)           \u2013            <p>An existing OCC curve.</p> </li> <li> <code>name</code>               (<code>str</code>, default:                   <code>None</code> )           \u2013            <p>The name of the curve.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dimension</code>               (<code>int</code>)           \u2013            <p>The dimension of the curve.</p> </li> <li> <code>domain</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The domain of the parameter space of the curve.</p> </li> <li> <code>end</code>               (<code>Point</code>)           \u2013            <p>The end point of the curve.</p> </li> <li> <code>is_closed</code>               (<code>bool</code>)           \u2013            <p>Flag indicating that the curve is closed.</p> </li> <li> <code>is_periodic</code>               (<code>bool</code>)           \u2013            <p>Flag indicating that the curve is periodic.</p> </li> <li> <code>start</code>               (<code>Point</code>)           \u2013            <p>The start point of the curve.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve-functions","title":"Functions","text":""},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.aabb","title":"aabb","text":"<pre><code>aabb(precision: float = 0.0) -&gt; Box\n</code></pre> <p>Compute the axis aligned bounding box of the curve.</p> <p>Parameters:</p> <ul> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The precision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Box</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.closest_parameters_curve","title":"closest_parameters_curve","text":"<pre><code>closest_parameters_curve(\n    curve: OCCCurve, return_distance: bool = False\n) -&gt; tuple[float, float] | tuple[tuple[float, float], float]\n</code></pre> <p>Computes the curve parameters where the curve is the closest to another given curve.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCCurve</code>)           \u2013            <p>The curve to find the closest distance to.</p> </li> <li> <code>return_distance</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the minimum distance between the two curves in addition to the curve parameters.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, float] | tuple[tuple[float, float], float]</code>           \u2013            <p>If <code>return_distance</code> is False, the lowest distance parameters on the two curves. If <code>return_distance</code> is True, the distance between the two curves in addition to the curve parameters.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.closest_point","title":"closest_point","text":"<pre><code>closest_point(\n    point: Point, return_parameter: bool = False\n) -&gt; Point | tuple[Point, float] | None\n</code></pre> <p>Compute the closest point on the curve to a given point. If an orthogonal projection is not possible, the start or end point is returned, whichever is closer.</p> <p>Parameters:</p> <ul> <li> <code>point</code>               (<code>Point</code>)           \u2013            <p>The point to project to the curve.</p> </li> <li> <code>return_parameter</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the curve parameter in addition to the closest point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Point | tuple[Point, float]</code>           \u2013            <p>If <code>return_parameter</code> is False, the nearest point on the curve. If <code>return_parameter</code> is True, the nearest point on the curve and the corresponding parameter.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.closest_points_curve","title":"closest_points_curve","text":"<pre><code>closest_points_curve(\n    curve: OCCCurve, return_distance: bool = False\n) -&gt; tuple[Point, Point] | tuple[tuple[Point, Point], float]\n</code></pre> <p>Computes the points on curves where the curve is the closest to another given curve.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCCurve</code>)           \u2013            <p>The curve to find the closest distance to.</p> </li> <li> <code>return_distance</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the minimum distance between the curves in addition to the closest points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[Point, Point] | tuple[tuple[Point, Point], float]</code>           \u2013            <p>If <code>return_distance</code> is False, the closest points. If <code>return_distance</code> is True, the distance in addition to the closest points.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCCurve\n</code></pre> <p>Make an independent copy of the current curve.</p> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.curvature_at","title":"curvature_at","text":"<pre><code>curvature_at(t: float) -&gt; Vector\n</code></pre> <p>Compute the curvature vector at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.divide_by_count","title":"divide_by_count","text":"<pre><code>divide_by_count(\n    count: int, return_points: bool = False, precision: float = 1e-06\n) -&gt; list[float] | tuple[list[float], list[Point]]\n</code></pre> <p>Divide the curve into a specific number of equal length segments.</p> <p>Parameters:</p> <ul> <li> <code>count</code>               (<code>int</code>)           \u2013            <p>The number of segments.</p> </li> <li> <code>return_points</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the list of division parameters, and the points corresponding to those parameters. If False, return only the list of parameters.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The precision used for calculating the segments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[float] | tuple[list[float], list[Point]]</code>           \u2013            <p>If <code>return_points</code> is False, the parameters of the discretisation. If <code>return_points</code> is True, a list of points in addition to the parameters of the discretisation.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.divide_by_length","title":"divide_by_length","text":"<pre><code>divide_by_length(\n    length: float, return_points: bool = False, precision: float = 1e-06\n) -&gt; list[float] | tuple[list[float], list[Point]]\n</code></pre> <p>Divide the curve into segments of a given length.</p> <p>Note that the end point of the last segment might not coincide with the end point of the curve.</p> <p>Parameters:</p> <ul> <li> <code>length</code>               (<code>float</code>)           \u2013            <p>The length of the segments.</p> </li> <li> <code>return_points</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the list of division parameters, and the points corresponding to those parameters. If False, return only the list of parameters.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>1e-06</code> )           \u2013            <p>The precision used for calculating the segments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[float] | tuple[list[float], list[Point]]</code>           \u2013            <p>If <code>return_points</code> is False, the parameters of the discretisation. If <code>return_points</code> is True, a list of points in addition to the parameters of the discretisation.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.embedded","title":"embedded","text":"<pre><code>embedded(surface) -&gt; OCCCurve2d\n</code></pre> <p>Return a new curve embedded in the parameter space of the surface.</p> <p>Parameters:</p> <ul> <li> <code>surface</code>           \u2013            <p>The embedding surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve2d</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.frame_at","title":"frame_at","text":"<pre><code>frame_at(t: float) -&gt; Frame\n</code></pre> <p>Compute the local frame at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(native_curve: Geom_Curve) -&gt; OCCCurve\n</code></pre> <p>Construct a curve from an existing OCC BSplineCurve.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom_Curve</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.from_occ","title":"from_occ  <code>classmethod</code>","text":"<pre><code>from_occ(native_curve: Geom_Curve) -&gt; OCCCurve\n</code></pre> <p>Construct a curve from an existing OCC BSplineCurve.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom_Curve</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul> Warnings <p>.. deprecated:: 1.3     Use <code>from_native</code> instead.</p>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.length","title":"length","text":"<pre><code>length(precision: float = 0.001) -&gt; float\n</code></pre> <p>Compute the length of the curve.</p> <p>Parameters:</p> <ul> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The precision used for calculating the length.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.offset","title":"offset","text":"<pre><code>offset(distance: float, direction: Vector) -&gt; OCCCurve\n</code></pre> <p>Return a new curve that is the offset of this curve over the specified distance in the given direction.</p> <p>Parameters:</p> <ul> <li> <code>distance</code>               (<code>float</code>)           \u2013            <p>The offset distance.</p> </li> <li> <code>direction</code>               (<code>Vector</code>)           \u2013            <p>The offset direction. Note that this direction defines the normal of the offset plane. At every point of the curve, a positive offset ditance will generate a corresponding offset point in the direction of the cross product vector of the curve tangent and the offset plane normal.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.parameter_at_distance","title":"parameter_at_distance","text":"<pre><code>parameter_at_distance(t: float, distance: float, precision: float = 0.1) -&gt; float\n</code></pre> <p>Compute the parameter of a point on the curve at a given distance along the curve from a point at a given parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The parameter of the starting point.</p> </li> <li> <code>distance</code>               (<code>float</code>)           \u2013            <p>The distance along the curve from the point at the given parameter.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The required precision of the result.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The new parameter.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.point_at","title":"point_at","text":"<pre><code>point_at(t: float) -&gt; Point\n</code></pre> <p>Compute the point at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Point</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.projected","title":"projected","text":"<pre><code>projected(surface) -&gt; OCCCurve\n</code></pre> <p>Return a copy of the curve projected onto a surface.</p> <p>Parameters:</p> <ul> <li> <code>surface</code>           \u2013            <p>The projection surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.reverse","title":"reverse","text":"<pre><code>reverse() -&gt; None\n</code></pre> <p>Reverse the parametrisation of the curve.</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.tangent_at","title":"tangent_at","text":"<pre><code>tangent_at(t: float) -&gt; Vector\n</code></pre> <p>Compute the tangent vector at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.to_polyline","title":"to_polyline","text":"<pre><code>to_polyline(n: int = 100) -&gt; Polyline\n</code></pre> <p>Convert the curve to a polyline.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The number of polyline points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>class:`compas.geometry.Polyline`</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.to_step","title":"to_step","text":"<pre><code>to_step(filepath: str, schema: str = 'AP203') -&gt; None\n</code></pre> <p>Write the curve geometry to a STP file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>The path to the file.</p> </li> <li> <code>schema</code>               (<code>str</code>, default:                   <code>'AP203'</code> )           \u2013            <p>The STEP schema.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve/#compas_occ.geometry.OCCCurve.transform","title":"transform","text":"<pre><code>transform(T: Transformation) -&gt; None\n</code></pre> <p>Transform this curve.</p> <p>Parameters:</p> <ul> <li> <code>T</code>               (<code>Transformation</code>)           \u2013            <p>A transformation matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/","title":"OCCCurve2d","text":""},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d","title":"OCCCurve2d","text":"<pre><code>OCCCurve2d(native_curve: Geom2d_Curve, name=None)\n</code></pre> <p>Class representing a general 2D curve object ussually generated through an embedding in a surface.</p> <p>Parameters:</p> <ul> <li> <code>name</code>           \u2013            <p>The name of the curve.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>dimension</code>               (<code>int</code>)           \u2013            <p>The dimension of the curve is always 2.</p> </li> <li> <code>domain</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The domain of the parameter space of the curve.</p> </li> <li> <code>end</code>               (<code>Point</code>)           \u2013            <p>The end point of the curve.</p> </li> <li> <code>is_closed</code>               (<code>bool</code>)           \u2013            <p>Flag indicating that the curve is closed.</p> </li> <li> <code>is_periodic</code>               (<code>bool</code>)           \u2013            <p>Flag indicating that the curve is periodic.</p> </li> <li> <code>start</code>               (<code>Point</code>)           \u2013            <p>The start point of the curve.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d-functions","title":"Functions","text":""},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCCurve2d\n</code></pre> <p>Make an independent copy of the current curve.</p> <p>Returns:</p> <ul> <li> <code>OCCCurve2d</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.curvature_at","title":"curvature_at","text":"<pre><code>curvature_at(t: float) -&gt; Vector\n</code></pre> <p>Compute the curvature vector at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.frame_at","title":"frame_at","text":"<pre><code>frame_at(t: float) -&gt; Frame\n</code></pre> <p>Compute the local frame at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(native_curve: Geom2d_Curve) -&gt; OCCCurve2d\n</code></pre> <p>Construct a NURBS curve from an existing OCC BSplineCurve.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom2d_Curve</code>)           \u2013            <p>An OCC Geom2d_Curve object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve2d</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.from_occ","title":"from_occ  <code>classmethod</code>","text":"<pre><code>from_occ(native_curve: Geom2d_Curve) -&gt; OCCCurve2d\n</code></pre> <p>Construct a NURBS curve from an existing OCC BSplineCurve.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom2d_Curve</code>)           \u2013            <p>An OCC Geom2d_Curve object.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve2d</code>           \u2013            </li> </ul> Warnings <p>.. deprecated:: 1.3     Use <code>from_native</code> instead.</p>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.point_at","title":"point_at","text":"<pre><code>point_at(t: float) -&gt; Point\n</code></pre> <p>Compute the point at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Point</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.tangent_at","title":"tangent_at","text":"<pre><code>tangent_at(t: float) -&gt; Vector\n</code></pre> <p>Compute the tangent vector at a curve parameter.</p> <p>Parameters:</p> <ul> <li> <code>t</code>               (<code>float</code>)           \u2013            <p>The curve parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector</code>           \u2013            </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the parameter is not in the curve domain.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.to_polyline","title":"to_polyline","text":"<pre><code>to_polyline(n: int = 100) -&gt; Polyline\n</code></pre> <p>Convert the curve to a polyline.</p> <p>Parameters:</p> <ul> <li> <code>n</code>               (<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The number of polyline points.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Polyline</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCCurve2d/#compas_occ.geometry.OCCCurve2d.to_step","title":"to_step","text":"<pre><code>to_step(filepath: str, schema: str = 'AP203') -&gt; None\n</code></pre> <p>Write the curve geometry to a STP file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>The path to the file.</p> </li> <li> <code>schema</code>               (<code>str</code>, default:                   <code>'AP203'</code> )           \u2013            <p>The STEP schema to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/","title":"OCCNurbsCurve","text":""},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve","title":"OCCNurbsCurve","text":"<pre><code>OCCNurbsCurve(native_curve: Geom_BSplineCurve, name: str | None = None)\n</code></pre> <p>Class representing a NURBS curve based on the BSplineCurve of the OCC geometry kernel.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the curve.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>continuity</code>               (<code>int</code>)           \u2013            <p>The degree of continuity of the curve.</p> </li> <li> <code>degree</code>               (<code>int</code>)           \u2013            <p>The degree of the curve.</p> </li> <li> <code>is_rational</code>               (<code>bool</code>)           \u2013            <p>Flag indicating that the curve is rational.</p> </li> <li> <code>knots</code>               (<code>list[float]</code>)           \u2013            <p>The knots of the curve, without multiplicities.</p> </li> <li> <code>knotsequence</code>               (<code>list[float]</code>)           \u2013            <p>The full vector of knots of the curve.</p> </li> <li> <code>multiplicities</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots of the curve.</p> </li> <li> <code>order</code>               (<code>int</code>)           \u2013            <p>The order of the curve (= degree + 1).</p> </li> <li> <code>points</code>               (<code>list[Point]</code>)           \u2013            <p>The control points of the curve.</p> </li> <li> <code>weights</code>               (<code>list[float]</code>)           \u2013            <p>The weights of the control points of the curve.</p> </li> </ul> <p>Examples:</p> <p>Curve from points...</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.geometry import OCCNurbsCurve\n&gt;&gt;&gt; points = [Point(0, 0, 0), Point(3, 6, 0), Point(6, -3, 3), Point(10, 0, 0)]\n&gt;&gt;&gt; curve = OCCNurbsCurve.from_points(points)\n</code></pre> <p>Curve from parameters...</p> <pre><code>&gt;&gt;&gt; from compas.geometry import Point\n&gt;&gt;&gt; from compas_occ.geometry import OCCNurbsCurve\n&gt;&gt;&gt; points = [Point(0, 0, 0), Point(3, 6, 0), Point(6, -3, 3), Point(10, 0, 0)]\n&gt;&gt;&gt; curve = OCCNurbsCurve.from_parameters(points=points, weights=[1.0, 1.0, 1.0, 1.0], knots=[0.0, 1.0], multiplicities=[4, 4], degree=3)\n</code></pre>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve-functions","title":"Functions","text":""},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCNurbsCurve\n</code></pre> <p>Make an independent copy of the current curve.</p> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_arc","title":"from_arc  <code>classmethod</code>","text":"<pre><code>from_arc(arc: Arc, degree: int, pointcount: int | None = None) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from an arc.</p> <p>Parameters:</p> <ul> <li> <code>arc</code>               (<code>Arc</code>)           \u2013            <p>The arc geometry.</p> </li> <li> <code>degree</code>               (<code>int</code>)           \u2013            <p>The degree of the resulting NURBS curve.</p> </li> <li> <code>pointcount</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The number of control points in the resulting NURBS curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_circle","title":"from_circle  <code>classmethod</code>","text":"<pre><code>from_circle(circle: Circle) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from a circle.</p> <p>Parameters:</p> <ul> <li> <code>circle</code>               (<code>Circle</code>)           \u2013            <p>The circle geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_ellipse","title":"from_ellipse  <code>classmethod</code>","text":"<pre><code>from_ellipse(ellipse: Ellipse) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from an ellipse.</p> <p>Parameters:</p> <ul> <li> <code>ellipse</code>               (<code>Ellipse</code>)           \u2013            <p>The ellipse geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_interpolation","title":"from_interpolation  <code>classmethod</code>","text":"<pre><code>from_interpolation(points: list[Point], precision: float = 0.001) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve by interpolating a set of points.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[Point]</code>)           \u2013            <p>The control points of the curve.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The precision of the interpolation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_line","title":"from_line  <code>classmethod</code>","text":"<pre><code>from_line(line: Line) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from a line.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>Line</code>)           \u2013            <p>The line geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(native_curve: Geom_BSplineCurve) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from an existing OCC BSplineCurve.</p> <p>Parameters:</p> <ul> <li> <code>native_curve</code>               (<code>Geom_BSplineCurve</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_parameters","title":"from_parameters  <code>classmethod</code>","text":"<pre><code>from_parameters(\n    points: list[Point],\n    weights: list[float],\n    knots: list[float],\n    multiplicities: list[int],\n    degree: int,\n    is_periodic: bool = False,\n) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from explicit curve parameters.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[Point]</code>)           \u2013            <p>The control points.</p> </li> <li> <code>weights</code>               (<code>list[float]</code>)           \u2013            <p>The weights of the control points.</p> </li> <li> <code>knots</code>               (<code>list[float]</code>)           \u2013            <p>The knots of the curve, without multiplicities.</p> </li> <li> <code>multiplicities</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots.</p> </li> <li> <code>degree</code>               (<code>int</code>)           \u2013            <p>The degree of the curve.</p> </li> <li> <code>is_periodic</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating that the curve is periodic.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.from_points","title":"from_points  <code>classmethod</code>","text":"<pre><code>from_points(points: list[Point], degree: int = 3) -&gt; OCCNurbsCurve\n</code></pre> <p>Construct a NURBS curve from control points.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[Point]</code>)           \u2013            <p>The control points of the curve.</p> </li> <li> <code>degree</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>The degree of the curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.join","title":"join","text":"<pre><code>join(curve: OCCNurbsCurve, precision: float = 0.0001) -&gt; None\n</code></pre> <p>Modifies this curve by joining it with another curve.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCNurbsCurve</code>)           \u2013            <p>The curve to join.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Tolerance for continuity and multiplicity.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.joined","title":"joined","text":"<pre><code>joined(curve: OCCNurbsCurve, precision: float = 0.0001) -&gt; OCCNurbsCurve | None\n</code></pre> <p>Returns a new curve that is the result of joining this curve with another.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCNurbsCurve</code>)           \u2013            <p>The curve to join.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.0001</code> )           \u2013            <p>Tolerance for continuity and multiplicity.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve | None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.segment","title":"segment","text":"<pre><code>segment(u: float, v: float, precision: float = 0.001) -&gt; None\n</code></pre> <p>Modifies this curve by segmenting it between the parameters u and v.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>Start parameter of the segment.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>End parameter of the segment.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The precision for the segmentation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsCurve/#compas_occ.geometry.OCCNurbsCurve.segmented","title":"segmented","text":"<pre><code>segmented(u: float, v: float, precision: float = 0.001) -&gt; OCCNurbsCurve\n</code></pre> <p>Returns a copy of this curve by segmenting it between the parameters u and v.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>Start parameter of the segment.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>End parameter of the segment.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The precision for the segmentation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/","title":"OCCNurbsSurface","text":""},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface","title":"OCCNurbsSurface","text":"<pre><code>OCCNurbsSurface(native_surface: Geom_Surface, name: str | None = None)\n</code></pre> <p>Class representing a NURBS surface based on the BSplineSurface of the OCC geometry kernel.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the curve</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>points</code>               (<code>ControlPoints</code>)           \u2013            <p>The control points of the surface.</p> </li> <li> <code>weights</code>               (<code>list[list[float]]</code>)           \u2013            <p>The weights of the control points of the surface.</p> </li> <li> <code>knots_u</code>               (<code>list[float]</code>)           \u2013            <p>The knots of the surface in the U direction, without multiplicities.</p> </li> <li> <code>knots_v</code>               (<code>list[float]</code>)           \u2013            <p>The knots of the surface in the V direction, without multiplicities.</p> </li> <li> <code>mults_u</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots of the surface in the U direction.</p> </li> <li> <code>mults_v</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots of the surface in the V direction.</p> </li> </ul> <p>Examples:</p> <p>Construct a surface from points...</p> <pre><code>from compas.geometry import Point\nfrom compas_occ.geometry import OCCNurbsSurface\n\npoints = [\n    [Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0), Point(3, 0, 0)],\n    [Point(0, 1, 0), Point(1, 1, 2), Point(2, 1, 2), Point(3, 1, 0)],\n    [Point(0, 2, 0), Point(1, 2, 2), Point(2, 2, 2), Point(3, 2, 0)],\n    [Point(0, 3, 0), Point(1, 3, 0), Point(2, 3, 0), Point(3, 3, 0)],\n]\n\nsurface = OCCNurbsSurface.from_points(points=points)\n</code></pre> <p>Construct a surface from points...</p> <pre><code>from compas.geometry import Point\nfrom compas_occ.geometry import OCCNurbsSurface\n\npoints = [\n    [Point(0, 0, 0), Point(1, 0, +0), Point(2, 0, +0), Point(3, 0, +0), Point(4, 0, +0), Point(5, 0, 0)],\n    [Point(0, 1, 0), Point(1, 1, -1), Point(2, 1, -1), Point(3, 1, -1), Point(4, 1, -1), Point(5, 1, 0)],\n    [Point(0, 2, 0), Point(1, 2, -1), Point(2, 2, +2), Point(3, 2, +2), Point(4, 2, -1), Point(5, 2, 0)],\n    [Point(0, 3, 0), Point(1, 3, -1), Point(2, 3, +2), Point(3, 3, +2), Point(4, 3, -1), Point(5, 3, 0)],\n    [Point(0, 4, 0), Point(1, 4, -1), Point(2, 4, -1), Point(3, 4, -1), Point(4, 4, -1), Point(5, 4, 0)],\n    [Point(0, 5, 0), Point(1, 5, +0), Point(2, 5, +0), Point(3, 5, +0), Point(4, 5, +0), Point(5, 5, 0)],\n]\n\nweights = [\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n    [1.0, 1.0, 1.0, 1.0, 1.0, 1.0],\n]\n\nsurface = OCCNurbsSurface.from_parameters(\n    points=points,\n    weights=weights,\n    knots_u=[1.0, 1 + 1 / 9, 1 + 2 / 9, 1 + 3 / 9, 1 + 4 / 9, 1 + 5 / 9, 1 + 6 / 9, 1 + 7 / 9, 1 + 8 / 9, 2.0],\n    knots_v=[0.0, 1 / 9, 2 / 9, 3 / 9, 4 / 9, 5 / 9, 6 / 9, 7 / 9, 8 / 9, 1.0],\n    mults_u=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    mults_v=[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    degree_u=3,\n    degree_v=3,\n)\n</code></pre>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface-functions","title":"Functions","text":""},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCNurbsSurface\n</code></pre> <p>Make an independent copy of the current surface.</p> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_extrusion","title":"from_extrusion  <code>classmethod</code>","text":"<pre><code>from_extrusion(curve: Curve, vector: Vector) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from an extrusion of a basis curve.</p> <p>Note that the extrusion surface is constructed by generating an infill between the basis curve and a translated copy with :meth:<code>from_fill</code>.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>Curve</code>)           \u2013            <p>The basis curve for the extrusion.</p> </li> <li> <code>vector</code>               (<code>Vector</code>)           \u2013            <p>The extrusion vector, which serves as a translation vector for the basis curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_fill","title":"from_fill  <code>classmethod</code>","text":"<pre><code>from_fill(\n    curve1: OCCNurbsCurve,\n    curve2: OCCNurbsCurve,\n    curve3: OCCNurbsCurve | None = None,\n    curve4: OCCNurbsCurve | None = None,\n    style: Literal[\"stretch\", \"coons\", \"curved\"] = \"stretch\",\n) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from the infill between two, three or four contiguous NURBS curves.</p> <p>Parameters:</p> <ul> <li> <code>curve1</code>               (<code>OCCNurbsCurve</code>)           \u2013            <p>The first boundary curve.</p> </li> <li> <code>curve2</code>               (<code>OCCNurbsCurve</code>)           \u2013            <p>The second boundary curve.</p> </li> <li> <code>curve3</code>               (<code>OCCNurbsCurve | None</code>, default:                   <code>None</code> )           \u2013            <p>The third boundary curve.</p> </li> <li> <code>curve4</code>               (<code>OCCNurbsCurve | None</code>, default:                   <code>None</code> )           \u2013            <p>The fourth boundary curve.</p> </li> <li> <code>style</code>               (<code>Literal['stretch', 'coons', 'curved']</code>, default:                   <code>'stretch'</code> )           \u2013            <p>The fill style. Options are:</p> <ul> <li><code>'stretch'</code> produces the flattest patch.</li> <li><code>'curved'</code> produces a rounded patch.</li> <li><code>'coons'</code> is between stretch and coons.</li> </ul> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the fill style is not supported.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_interpolation","title":"from_interpolation  <code>classmethod</code>","text":"<pre><code>from_interpolation(\n    points: list[list[Point]], precision: float = 0.001\n) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface by approximating or interpolating a 2D collection of points.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[list[Point]]</code>)           \u2013            <p>The 2D collection of points.</p> </li> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The fitting precision.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(native_surface: Geom_BSplineSurface) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from an existing OCC Surface.</p> <p>Parameters:</p> <ul> <li> <code>native_surface</code>               (<code>Geom_BSplineSurface</code>)           \u2013            <p>An OCC surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            <p>The constructed surface.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_parameters","title":"from_parameters  <code>classmethod</code>","text":"<pre><code>from_parameters(\n    points: list[list[Point]],\n    weights: list[list[float]],\n    knots_u: list[float],\n    knots_v: list[float],\n    mults_u: list[int],\n    mults_v: list[int],\n    degree_u: int,\n    degree_v: int,\n    is_periodic_u: bool = False,\n    is_periodic_v: bool = False,\n) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from explicit parameters.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[list[Point]]</code>)           \u2013            <p>The control points of the surface.</p> </li> <li> <code>weights</code>               (<code>list[list[float]]</code>)           \u2013            <p>The weights of the control points.</p> </li> <li> <code>knots_u</code>               (<code>list[float]</code>)           \u2013            <p>The knots in the U direction, without multiplicities.</p> </li> <li> <code>knots_v</code>               (<code>list[float]</code>)           \u2013            <p>The knots in the V direction, without multiplicities.</p> </li> <li> <code>mults_u</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots in the U direction.</p> </li> <li> <code>mults_v</code>               (<code>list[int]</code>)           \u2013            <p>The multiplicities of the knots in the V direction.</p> </li> <li> <code>u_dergee</code>           \u2013            <p>Degree in the U direction.</p> </li> <li> <code>degree_v</code>               (<code>int</code>)           \u2013            <p>Degree in the V direction.</p> </li> <li> <code>is_periodic_u</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating that the surface is periodic in the U direction.</p> </li> <li> <code>is_periodic_v</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Flag indicating that the surface is periodic in the V direction.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_plane","title":"from_plane  <code>classmethod</code>","text":"<pre><code>from_plane(plane: Plane) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from a plane.</p> <p>Parameters:</p> <ul> <li> <code>plane</code>               (<code>Plane</code>)           \u2013            <p>The plane to construct the surface from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCNurbsSurface/#compas_occ.geometry.OCCNurbsSurface.from_points","title":"from_points  <code>classmethod</code>","text":"<pre><code>from_points(\n    points: list[list[Point]], degree_u: int = 3, degree_v: int = 3\n) -&gt; OCCNurbsSurface\n</code></pre> <p>Construct a NURBS surface from control points.</p> <p>Parameters:</p> <ul> <li> <code>points</code>               (<code>list[list[Point]]</code>)           \u2013            <p>The control points.</p> </li> <li> <code>degree_u</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Degree in the U direction.</p> </li> <li> <code>degree_v</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Degree in the V direction.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCNurbsSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/","title":"OCCSurface","text":""},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface","title":"OCCsurface","text":"<pre><code>OCCSurface(native_surface: Geom_Surface, name: str | None = None)\n</code></pre> <p>Class representing a general surface object.</p> <p>Parameters:</p> <ul> <li> <code>native_surface</code>               (<code>Geom_Surface</code>)           \u2013            <p>The native OCC surface.</p> </li> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the surface.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>continuity</code>           \u2013            <p>The degree of continuity of the surface.</p> </li> <li> <code>degree_u</code>           \u2013            <p>The degree of the surface in the U direction.</p> </li> <li> <code>degree_v</code>           \u2013            <p>The degree of the surface in the V direction.</p> </li> <li> <code>domain_u</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The parameter domain of the surface in the U direction.</p> </li> <li> <code>domain_v</code>               (<code>tuple[float, float]</code>)           \u2013            <p>The parameter domain of the surface in the V direction.</p> </li> <li> <code>is_periodic_u</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the surface is periodic in the U direction.</p> </li> <li> <code>is_periodic_v</code>               (<code>bool</code>)           \u2013            <p>Flag indicating if the surface is periodic in the V direction.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface-functions","title":"Functions","text":""},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.aabb","title":"aabb","text":"<pre><code>aabb(precision: float = 0.0, optimal: bool = False) -&gt; Box\n</code></pre> <p>Compute the axis aligned bounding box of the surface.</p> <p>Parameters:</p> <ul> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The precision for the bounding box computation.</p> </li> <li> <code>optimal</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to compute an optimal bounding box.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Box</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.boundary","title":"boundary","text":"<pre><code>boundary() -&gt; list[OCCCurve]\n</code></pre> <p>Compute the boundary curves of the surface.</p> <p>Returns:</p> <ul> <li> <code>list[OCCCurve]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.closest_point","title":"closest_point","text":"<pre><code>closest_point(\n    point: Point, return_parameters: bool = False\n) -&gt; Point | tuple[Point, tuple[float, float]]\n</code></pre> <p>Compute the closest point on the curve to a given point.</p> <p>Parameters:</p> <ul> <li> <code>point</code>               (<code>Point</code>)           \u2013            <p>The point to project to the surface.</p> </li> <li> <code>return_parameters</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, return the surface UV parameters in addition to the closest point.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Point | tuple[Point, tuple[float, float]]</code>           \u2013            <p>If <code>return_parameters</code> is False, the nearest point on the surface. If <code>return_parameters</code> is True, the UV parameters in addition to the nearest point on the surface.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.copy","title":"copy","text":"<pre><code>copy() -&gt; OCCSurface\n</code></pre> <p>Make an independent copy of the current surface.</p> <p>Returns:</p> <ul> <li> <code>OCCSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.curvature_at","title":"curvature_at","text":"<pre><code>curvature_at(u: float, v: float) -&gt; Vector\n</code></pre> <p>Compute the curvature at a point on the surface.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>The U parameter.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>The V parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.frame_at","title":"frame_at","text":"<pre><code>frame_at(u: float, v: float) -&gt; Frame\n</code></pre> <p>Compute the local frame at a point on the curve.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>The U parameter.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>The V parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Frame</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.from_face","title":"from_face  <code>classmethod</code>","text":"<pre><code>from_face(face: TopoDS_Face) -&gt; OCCSurface\n</code></pre> <p>Construct a surface from an existing OCC TopoDS_Face.</p> <p>Parameters:</p> <ul> <li> <code>face</code>               (<code>TopoDS_Face</code>)           \u2013            <p>An OCC face in wich the surface is embedded.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCSurface</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.from_native","title":"from_native  <code>classmethod</code>","text":"<pre><code>from_native(native_surface: Geom_Surface) -&gt; OCCSurface\n</code></pre> <p>Construct a surface from an existing OCC Surface.</p> <p>Parameters:</p> <ul> <li> <code>native_surface</code>               (<code>Geom_Surface</code>)           \u2013            <p>An OCC surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCSurface</code>           \u2013            <p>The constructed surface.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.from_occ","title":"from_occ  <code>classmethod</code>","text":"<pre><code>from_occ(native_surface: Geom_Surface) -&gt; OCCSurface\n</code></pre> <p>Construct a surface from an existing OCC Surface.</p> <p>Parameters:</p> <ul> <li> <code>native_surface</code>               (<code>Geom_Surface</code>)           \u2013            <p>An OCC surface.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCSurface</code>           \u2013            <p>The constructed surface.</p> </li> </ul> Warnings <p>.. deprecated:: 1.3     Use <code>from_native</code> instead</p>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.gaussian_curvature_at","title":"gaussian_curvature_at","text":"<pre><code>gaussian_curvature_at(u: float, v: float) -&gt; float\n</code></pre> <p>Compute the Gaussian curvature at a point on the surface.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>The U parameter.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>The V parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.intersections_with_curve","title":"intersections_with_curve","text":"<pre><code>intersections_with_curve(curve: OCCCurve) -&gt; list[Point]\n</code></pre> <p>Compute the intersections with a curve.</p> <p>Parameters:</p> <ul> <li> <code>curve</code>               (<code>OCCCurve</code>)           \u2013            <p>The intersecting curve.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Point]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.intersections_with_line","title":"intersections_with_line","text":"<pre><code>intersections_with_line(line: Line) -&gt; list[Point]\n</code></pre> <p>Compute the intersections with a line.</p> <p>Parameters:</p> <ul> <li> <code>line</code>               (<code>Line</code>)           \u2013            <p>The intersecting line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Point]</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.isocurve_u","title":"isocurve_u","text":"<pre><code>isocurve_u(u: float) -&gt; OCCCurve\n</code></pre> <p>Compute the isoparametric curve at parameter u.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>The parameter value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.isocurve_v","title":"isocurve_v","text":"<pre><code>isocurve_v(v: float) -&gt; OCCCurve\n</code></pre> <p>Compute the isoparametric curve at parameter v.</p> <p>Parameters:</p> <ul> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>The parameter value.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>OCCCurve</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.mean_curvature_at","title":"mean_curvature_at","text":"<pre><code>mean_curvature_at(u: float, v: float) -&gt; float\n</code></pre> <p>Compute the mean curvature at a point on the surface.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            <p>The U parameter.</p> </li> <li> <code>v</code>               (<code>float</code>)           \u2013            <p>The V parameter.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.obb","title":"obb","text":"<pre><code>obb(precision: float = 0.0) -&gt; Box\n</code></pre> <p>Compute the oriented bounding box of the surface.</p> <p>Parameters:</p> <ul> <li> <code>precision</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The precision for the bounding box computation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Box</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.point_at","title":"point_at","text":"<pre><code>point_at(u: float, v: float) -&gt; Point\n</code></pre> <p>Compute a point on the surface.</p> <p>Parameters:</p> <ul> <li> <code>u</code>               (<code>float</code>)           \u2013            </li> <li> <code>v</code>               (<code>float</code>)           \u2013            </li> </ul> <p>Returns:</p> <ul> <li> <code>Point</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.to_step","title":"to_step","text":"<pre><code>to_step(filepath: str, schema: str = 'AP203') -&gt; None\n</code></pre> <p>Write the surface geometry to a STP file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>The path to the output file.</p> </li> <li> <code>schema</code>               (<code>str</code>, default:                   <code>'AP203'</code> )           \u2013            <p>The STEP schema to use.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.to_tesselation","title":"to_tesselation","text":"<pre><code>to_tesselation() -&gt; Mesh\n</code></pre> <p>Convert the surface to a triangle mesh.</p> <p>Returns:</p> <ul> <li> <code>Mesh</code>           \u2013            <p>The tesselated surface as a triangle mesh.</p> </li> </ul>"},{"location":"api/compas_occ.geometry.OCCSurface/#compas_occ.geometry.OCCSurface.transform","title":"transform","text":"<pre><code>transform(T: Transformation) -&gt; None\n</code></pre> <p>Transform this surface.</p> <p>Parameters:</p> <ul> <li> <code>T</code>               (<code>Transformation</code>)           \u2013            <p>A transformation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul>"},{"location":"examples/breps/","title":"Breps","text":"<ul> <li>Brep Shape From Booleans</li> <li>Brep From Mesh </li> <li>Find the Overlap Between Two Breps</li> <li>Slice a Brep With a Plane</li> <li>Split a Brep With a Plane</li> <li>Trim a Brep With a Plane</li> <li>Brep with Hole</li> <li>Brep with Holes</li> </ul>"},{"location":"examples/breps/brep_explorer/","title":"Explore Brep Topology","text":"<pre><code>from compas_viewer import Viewer\n\nfrom compas.colors import Color\nfrom compas.geometry import Box\nfrom compas_occ.brep import OCCBrep\n\nbox = OCCBrep.from_box(Box(1))\n\nvertex = box.vertices[0]\nvertices = box.vertex_neighbors(vertex)\nedges = box.vertex_edges(vertex)\nfaces = box.vertex_faces(vertex)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [2, -4, 1]\n\nviewer.scene.add(vertex.point, pointcolor=Color.red(), pointsize=20)\n\nfor vertex in vertices:\n    viewer.scene.add(vertex.point, pointsize=20)\n\nfor edge in edges:\n    viewer.scene.add(edge.to_line(), linewidth=5, linecolor=Color(0.2, 0.2, 0.2))\n\nfor face in faces:\n    brep = OCCBrep.from_brepfaces([face])\n    viewer.scene.add(brep, opacity=0.5)\n\nviewer.scene.add(box, linewidth=2, linecolor=Color(0.2, 0.2, 0.2), show_faces=False, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_fillet/","title":"Add a Fillet to the Edges of a Brep","text":"<pre><code>from pathlib import Path\n\nfrom compas_viewer import Viewer\n\nfrom compas_occ.brep import OCCBrep\n\n# Load the brep from a STEP file\n# and extract the individual letters.\n\nfilepath = Path(__file__).parent / \"FCA.stp\"\nbrep = OCCBrep.from_step(filepath)\nletters = list(brep.solids)\n\n# Make sure the letters are valid solids.\n\nfor letter in letters:\n    letter.heal()\n    letter.make_solid()\n\n# For each letter, exclude the edges that are too short and the edges connected to it,\n# and fillet the rest.\n\nfor letter in letters:\n    exclude = []\n    for loop in letter.loops:\n        do_fillet = True\n        for edge in loop.edges:\n            for vertex in edge.vertices:\n                if any(e.length &lt; 0.01 for e in letter.vertex_edges(vertex)):\n                    do_fillet = False\n                    break\n            if not do_fillet:\n                break\n        if not do_fillet:\n            for vertex in loop.vertices:\n                for edge in letter.vertex_edges(vertex):\n                    exclude.append(edge)\n\n    letter.fillet(0.1, exclude=exclude)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [5, 2, 0]\nviewer.renderer.camera.position = [5, -1, 10]\n\nfor letter in letters:\n    viewer.scene.add(letter, linewidth=2, opacity=0.7, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_from_booleans/","title":"Brep Shape From Booleans","text":"<pre><code>from compas_viewer import Viewer\n\nfrom compas.geometry import Box\nfrom compas.geometry import Cylinder\nfrom compas.geometry import Frame\nfrom compas.tolerance import TOL\n\n# from compas_occ.brep import OCCBrep\n\nTOL.lineardeflection = 0.1\n\nR = 1.4\nYZ = Frame.worldYZ()\nZX = Frame.worldZX()\nXY = Frame.worldXY()\n\nbox = Box(2 * R).to_brep()\ncx = Cylinder(0.7 * R, 4 * R, frame=YZ).to_brep()\ncy = Cylinder(0.7 * R, 4 * R, frame=ZX).to_brep()\ncz = Cylinder(0.7 * R, 4 * R, frame=XY).to_brep()\n\n# result = OCCBrep.from_boolean_difference(box, [cx, cy, cz])\nresult = box - (cx + cy + cz)\n\nresult.to_step(\"/Users/vanmelet/Desktop/booleans.step\")\n\n# ==============================================================================\n# Visualisation\n# ==============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [4, -6, 2]\n\nviewer.scene.add(result, linewidth=2, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_from_mesh/","title":"Brep From Mesh","text":"<pre><code>from compas_viewer import Viewer\n\nimport compas\nfrom compas.datastructures import Mesh\nfrom compas.geometry import Brep\n\n# Construct a mesh from an OBJ file\n# and convert to a brep\n\nmesh: Mesh = Mesh.from_obj(compas.get(\"tubemesh.obj\"))\nbrep = Brep.from_mesh(mesh)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [1, 1, 1]\nviewer.renderer.camera.position = [1, -6, 2]\n\nviewer.scene.add(brep, linewidth=2, show_points=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_overlap/","title":"Find the Overlap Between Two Breps","text":"<pre><code>from compas_viewer import Viewer\n\nfrom compas.colors import Color\nfrom compas.geometry import Box\nfrom compas.geometry import Brep\n\nA = Box(1).to_brep()\n\nbox = Box(1)\nbox.translate([1, 0.3, 0.5])\nB = Brep.from_box(box)\n\nFA, FB = A.overlap(B)  # type: ignore\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [-1, 2, 0]\nviewer.renderer.camera.position = [3, -3, 1]\n\nviewer.scene.add(A, opacity=0.5, linewidth=3)\nviewer.scene.add(B, opacity=0.5, linewidth=3)\n\nfor face in FA[:1]:\n    brep = Brep.from_brepfaces([face])\n    viewer.scene.add(\n        brep,\n        surfacecolor=Color.red().lightened(50),\n        linewidth=3,\n        linecolor=Color.red(),\n    )\n\nfor face in FB[:1]:\n    brep = Brep.from_brepfaces([face])\n    viewer.scene.add(\n        brep,\n        surfacecolor=Color.blue().lightened(50),\n        linewidth=3,\n        linecolor=Color.blue(),\n    )\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_slice/","title":"Slice a Brep With a Plane","text":"<pre><code>from math import radians\n\nfrom compas_viewer import Viewer\n\nfrom compas.geometry import Box\nfrom compas.geometry import Plane\nfrom compas.geometry import Rotation\n\nbox = Box(1).to_brep()\n\nplane = Plane.worldXY()\nR = Rotation.from_axis_and_angle([0, 1, 0], radians(30))\nplane.transform(R)\n\nslice = box.slice(plane)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [2, -4, 1]\n\nviewer.scene.add(box, opacity=0.5, show_points=False)\nviewer.scene.add(slice, linewidth=2)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_split/","title":"Split a Brep With a Plane","text":"<pre><code>from math import radians\n\nfrom compas_viewer import Viewer\n\nfrom compas.colors import Color\nfrom compas.geometry import Box\nfrom compas.geometry import Brep\nfrom compas.geometry import Plane\nfrom compas.geometry import Rotation\nfrom compas.geometry import is_point_infrontof_plane\n\nbox = Box(1).to_brep()\n\nR = Rotation.from_axis_and_angle([0, 1, 0], radians(30))\nplane = Plane.worldXY()\nplane.transform(R)\nsplitter = Brep.from_plane(plane, domain_u=(-2, +2), domain_v=(-2, +2))\n\nresult = box.split(splitter)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [2, -4, 1]\n\nviewer.scene.add(splitter, linewidth=2, opacity=0.3)\n\nfor brep in result:  # type: ignore\n    if is_point_infrontof_plane(brep.centroid, plane):\n        viewer.scene.add(\n            brep,\n            surfacecolor=Color.red().lightened(50),\n            linecolor=Color.red(),\n            linewidth=2,\n            show_points=False,\n        )\n    else:\n        viewer.scene.add(\n            brep,\n            surfacecolor=Color.blue().lightened(50),\n            linecolor=Color.blue(),\n            linewidth=2,\n            show_points=False,\n        )\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_trim/","title":"Trim a Brep With a Plane","text":"<pre><code>from math import radians\n\nfrom compas_viewer import Viewer\n\nfrom compas.geometry import Box\nfrom compas.geometry import Plane\nfrom compas.geometry import Rotation\n\nbox = Box(1).to_brep()\n\nR = Rotation.from_axis_and_angle([0, 1, 0], radians(30))\nplane = Plane.worldXY()\nplane.transform(R)\n\ntrimmed = box.trimmed(plane)\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\n\nviewer.renderer.camera.target = [0, 0, 0]\nviewer.renderer.camera.position = [2, -4, 1]\n\nviewer.scene.add(plane, opacity=0.5)\nviewer.scene.add(trimmed, linewidth=2, show_points=False)\nviewer.scene.add(box, linewidth=1, show_points=False, show_faces=False)\n\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_with_hole/","title":"Brep with Hole","text":"<pre><code># type: ignore\n# this should be included in the compas API\nfrom compas_viewer import Viewer\n\nfrom compas.geometry import Brep\nfrom compas.geometry import Circle\nfrom compas.geometry import Frame\nfrom compas.geometry import NurbsCurve\nfrom compas.geometry import NurbsSurface\nfrom compas.geometry import Point\nfrom compas.geometry import Vector\nfrom compas_occ.brep import OCCBrepEdge\nfrom compas_occ.brep import OCCBrepFace\nfrom compas_occ.brep import OCCBrepLoop\n\npoints = [\n    [Point(0, 0, 0), Point(1, 0, 0), Point(2, 0, 0), Point(3, 0, 0)],\n    [Point(0, 1, 0), Point(1, 1, 2), Point(2, 1, 2), Point(3, 1, 0)],\n    [Point(0, 2, 0), Point(1, 2, 2), Point(2, 2, 2), Point(3, 2, 0)],\n    [Point(0, 3, 0), Point(1, 3, 0), Point(2, 3, 0), Point(3, 3, 0)],\n]\n\nsurface = NurbsSurface.from_points(points=points)\n\ncircle = Circle(\n    0.5,\n    frame=Frame(\n        Point(1.5, 1.5, 1.5),\n        Vector(1, 0, 0),\n        Vector(0, 1, 0),\n    ),\n)\n\n# projected is still 3D\n# embedded is 2D\n# and the 2D curve should keep track of the embedding surface\ncurve = NurbsCurve.from_circle(circle)\n\nedge = OCCBrepEdge.from_curve(curve=curve, surface=surface)\nloop = OCCBrepLoop.from_edges([edge])\n\n# perhaps this should be:\n# face = OCCBrepFace()\n# face.set_surface(surface)\n# face.add_boundary(loop) =&gt; if the loop edges are not embedded in the surface, they should be\n# face.add_hole(loop) =&gt; if the loop edges ...\nface = OCCBrepFace.from_surface(surface)\nface.add_loop(loop)\n\nbrep = Brep.from_brepfaces([face])\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\nviewer.scene.add(brep, linewidth=2, show_points=False)\nviewer.show()\n</code></pre>"},{"location":"examples/breps/brep_with_holes/","title":"Brep with Holes","text":"<pre><code>from compas_viewer import Viewer\n\nfrom compas.geometry import Brep\nfrom compas.geometry import Circle\nfrom compas.geometry import Frame\nfrom compas.geometry import Plane\nfrom compas_occ.brep import OCCBrepEdge\nfrom compas_occ.brep import OCCBrepFace\nfrom compas_occ.brep import OCCBrepLoop\n\ncircle1 = Circle(1.0, frame=Frame([2, 2, 0]))\ncircle2 = Circle(2.0, frame=Frame([-2, -2, 0]))\ncircle3 = Circle(0.5, frame=Frame([2, -2, 0]))\n\nloop1 = OCCBrepLoop.from_edges([OCCBrepEdge.from_circle(circle1)])\nloop2 = OCCBrepLoop.from_edges([OCCBrepEdge.from_circle(circle2)])\nloop3 = OCCBrepLoop.from_edges([OCCBrepEdge.from_circle(circle3)])\n\nface = OCCBrepFace.from_plane(Plane.worldXY(), domain_u=(-5, 5), domain_v=(-5, 5))\nface.add_loops([loop1, loop2, loop3], reverse=True)\n\nbrep = Brep.from_brepfaces([face])\n\n# =============================================================================\n# Visualization\n# =============================================================================\n\nviewer = Viewer()\nviewer.scene.add(brep, linewidth=2, show_point=False)\nviewer.show()\n</code></pre>"}]}